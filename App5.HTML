<!doctype html>
<html lang="en">
<head>
	<title>ParticleSystem - Dynamic (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>


<script src="js/Three.js"></script>

<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/jquery-2.1.1.min.js"></script>




<!-- Custom shaders for particle effects -->
<script type="x-shader/x-vertex" id="vertexshader">
uniform float time;
attribute float customFrequency;
attribute float customSize;
attribute vec3 customColor;
varying vec3 vColor;
void main() 
{
	vColor = customColor; // set color associated to vertex; use later in fragment shader
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = sin(time) * customSize * 8.0 * ( 10.0 / length( mvPosition.xyz ) );
	gl_Position = projectionMatrix * mvPosition;
}
</script>



<script type="x-shader/x-fragment" id="fragmentshader">
uniform sampler2D texture;
varying vec3 vColor; // colors associated to vertices; assigned by vertex shader
void main() 
{
	// calculates a color for the particle
	gl_FragColor = vec4( vColor, 1.0 );
	// sets particle texture to desired color
	gl_FragColor = gl_FragColor;
}
</script>
<!-- end of custom shaders -->




<!-- jQuery code to display an information button and box when clicked. -->
<script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<script src="js/info.js"></script>



<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
*/

// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

// global variables
var cube;
var zeroCounter = 0;
var particleGeo = new THREE.Geometry();
var vertexCounter = 0;

init();
animate();

var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
direction = new THREE.Vector3( 1, 0, 0 );
myRaycaster = new THREE.Raycaster(camera.position, direction);


var cameraVector = new THREE.Vector3( 0, 0, -1 );
var new_pos = new THREE.Vector3( 0, 0, 0 );
var new_pos2 = new THREE.Vector3( 0, 0, 0 );
var raycaster;
var planeZ = new THREE.Plane(cameraVector, 0);


// FUNCTIONS
 	
function map(x,a,b,c,d){
		return (x-a)/(b-a) * (d-c) + c;
}
	
	
Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};

 
 
	
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	
	projector = new THREE.Projector();
	
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 1000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,10,10);
	camera.lookAt(scene.position);	
	
	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
	renderer = new THREE.CanvasRenderer(); 
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	$( document ).ready(function(){
    $(window).keypress(onKeyDown);
    $(window).mousemove(onMouseMove);
  });

	
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	
	// LIGHT
	var light = new THREE.PointLight(0xffffff);
	light.position.set(0,250,0);
	scene.add(light);
	
	// SKYBOX/FOG
	var skyBoxGeometry = new THREE.CubeGeometry( 100, 100, 100 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xeeeeee, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
  skyBox.flipSided = true; // render faces from inside of the cube, instead of from outside (default).
	scene.add(skyBox);
	scene.fog = new THREE.FogExp2( 0xeeeeee, 1 );
	
	// Mouse
	
	var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: 0.5 } );
 
	var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
  var pointer = new THREE.Mesh( mouseGeo, pointerMaterial );

  pointer.name = "pointer";
  pointer.position.x = 10;
  pointer.position.y = 10;
  pointer.position.z = 10;
  pointer.updateMatrix();
  pointer.matrixAutoUpdate = false;
  scene.add( pointer );
  
	////////////
	// CUSTOM //
	////////////
	
	var shaderMaterial;
	var particleSystem;
	
	var cubeGeometry = new THREE.CubeGeometry( 50, 50, 50, 20, 20, 20 );
	var discTexture = THREE.ImageUtils.loadTexture( 'disc.png' );
	
	// values that are constant for all particles during a draw call
	this.customUniforms = 
	{
		time:	 { type: "f", value: 1.0 },
		texture: { type: "t", value: discTexture },
	};
	
	// properties that may vary from particle to particle. only accessible in vertex shaders!
	//	(can pass color info to fragment shader via vColor.)
	this.customAttributes = 
	{
		customColor:	 { type: "c", value: [] },
		customFrequency: { type: 'f', value: [] },
		customSize: { type: 'f', value: [] }
	};
	
	

   
   $.getJSON( "LOGFILE_15.json", function( data ) {
       pointData = data;
       check();
       
   });   

          
   function check() {
        particlesCount = Math.floor(Object.size(pointData.points) / 3);

				var color = new THREE.Color();
	
				
     for ( var i = 0; i < particlesCount * 3; i += 3 ) {
       
       	// Eliminate zero dots
				if(y + x + z == 0){ 
				  continue;
					y = 500000;
					x = 500000;
					z = 500000;
					zeroCounter ++;
				}
				
       vertexCounter ++;

       if(pointData.points[i] == undefined && i <=  particlesCount * 3){
					console.log("something is wrong in the data at: " + i);
					continue;
       }


				// Point on XZ Plane
				var x = pointData.points[i].x * Math.cos(pointData.points[i].y*(Math.PI/180));
				var y = 0;
				var z = pointData.points[i].x * Math.sin(pointData.points[i].y*(Math.PI/180));
				
				var angle = (map(pointData.points[i].z, 212, 812, 0, 180))*(Math.PI/180);
				
				//Translate Point
				 x -= 40 * Math.cos(angle);
				 y -= 40 * Math.sin(angle);
				 z -= 0;
				
				// Rotate Point around Z Axis
				x1 = x * Math.cos(angle) - y * Math.sin(angle);
				y1 = x * Math.sin(angle) + y * Math.cos(angle);
				z1 = z;
				

				var colorMapR = map(pointData.points[i].x, 0, 8000, .5, 0);
				var colorMapG = map(pointData.points[i].x, 0, 3000, 0, .5);
				var colorMapB = map(pointData.points[i].x, 0, 8000, .5, 0);


        var newColor = new THREE.Color( 0xffffff );
        newColor.setRGB(colorMapR,colorMapG,colorMapB);
        
        particleGeo.vertices.push(
           new THREE.Vector3( y1 * 0.001, 	x1 * 0.001, 	z1 * 0.001)                
        );
        
        customAttributes.customColor.value[ vertexCounter-1] = newColor;
        customAttributes.customSize.value[ vertexCounter-1] =  map(pointData.points[i].x, 0, 5000, 0, 1);

			}
		

    	this.shaderMaterial = new THREE.ShaderMaterial( 
    	{
    		uniforms: 		customUniforms,
    		attributes:		customAttributes,
    		vertexShader:   document.getElementById( 'vertexshader' ).textContent,
    		fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
    		transparent: true, alphaTest: 0.5,  // if having transparency issues, try including: alphaTest: 0.5, 
    		// blending: THREE.AdditiveBlending, depthTest: false,
    	});
    	
    	
      this.particleSystem = new THREE.ParticleSystem( particleGeo, this.shaderMaterial );
    	this.particleSystem.position.set(0, 0, 0);
    	this.particleSystem.dynamic = true;
    	this.particleSystem.frustrumCulled = true;
    	this.particleSystem.sortParticles = false;
    	scene.add( this.particleSystem );
		}

}

function onMouseMove(event){
  
	// Create Camera Vector
  cameraVector.applyQuaternion( camera.quaternion );
   
	mouseX = event.clientX;
	//console.log(event.clientX)
	// Mouse Position on Screen (Worldpos?)
   var mv = new THREE.Vector3(
       (event.clientX / window.innerWidth) * 2 - 1,
       -(event.clientY / window.innerHeight) * 2 + 1,
       0.5 );
     
	//New Projector Class picking ray
   raycaster = projector.pickingRay(mv, camera);

   var pos = raycaster.ray.intersectPlane(planeZ);


     // Position object near camera - move it along vector between camera and calculated
     // pos
		
		 if(pos != null){
			 new_pos2.copy(pos);  
			}


     new_pos2.sub(camera.position);


     new_pos2.normalize();
     new_pos2.multiplyScalar(10);

     new_pos2.add(camera.position);

     object = scene.getObjectByName( "pointer" );


     object.position.set(new_pos2.x,new_pos2.y,new_pos2.z);
     object.updateMatrix();
  

};

function onKeyDown(event) {

             for ( var i = 0; i < particlesCount; i ++ ) {
              
             var vertex = particleGeo.vertices[i];
             
              //Get the current camera position  
             new_pos.copy(camera.position);
             
             //Get the smallest distance to the cube and if the distance is smaller than
             // the distance from camera to cube divided by ten (imaginary contact with sphere),
             // change the color
             if(raycaster.ray.distanceToPoint(vertex) <= new_pos.sub(vertex).length()/10 ){
                  
                 // console.log(i);
                  
                  var newColor = new THREE.Color( 0xffffff );
                  customAttributes.customColor.value[ i ] = newColor;
                  	
								  customAttributes.customColor.needsUpdate = true;
              }
              
             }
     
    
};

function animate() 
{
  requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	if ( keyboard.pressed("z") ) 
	{ 
		// do something
	}
	
	controls.update();
	stats.update();
	
	var t = clock.getElapsedTime();
	//customUniforms.time.value = 0.1;
}

function render() 
{
	renderer.render( scene, camera );
}

</script>

</body>
</html>