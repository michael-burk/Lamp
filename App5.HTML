<!doctype html>
<html lang="en">
<head>
	<title>ParticleSystem - Dynamic (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>


<script src="js/Three.js"></script>

<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/jquery-2.1.1.min.js"></script>




<!-- Custom shaders for particle effects -->
<script type="x-shader/x-vertex" id="vertexshader">
uniform float time;
attribute float customFrequency;
attribute float customSize;
attribute vec3 customColor;
varying vec3 vColor;
void main() 
{
	vColor = customColor; // set color associated to vertex; use later in fragment shader
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = customSize * 8.0 * ( 10.0 / length( mvPosition.xyz ) );
	gl_Position = projectionMatrix * mvPosition;
}
</script>



<script type="x-shader/x-fragment" id="fragmentshader">
uniform sampler2D texture;
varying vec3 vColor; // colors associated to vertices; assigned by vertex shader
void main() 
{
	// calculates a color for the particle
	gl_FragColor = vec4( vColor, 1.0 );
	// sets particle texture to desired color
	gl_FragColor = gl_FragColor;
}
</script>
<!-- end of custom shaders -->




<!-- jQuery code to display an information button and box when clicked. -->
<script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<script src="js/info.js"></script>



<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
*/

// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
// custom global variables
var cube;
var zeroCounter = 0;
var particleGeo = new THREE.Geometry();
//var positions;
//var colors;
var vertexCounter = 0;

init();
animate();


	function map(x,a,b,c,d){
		return (x-a)/(b-a) * (d-c) + c;
	}
	
	
Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};

 
 
// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 1000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,10,10);
	camera.lookAt(scene.position);	
	
	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
	renderer = new THREE.CanvasRenderer(); 
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	
	// LIGHT
	var light = new THREE.PointLight(0xffffff);
	light.position.set(0,250,0);
	scene.add(light);
	
	// SKYBOX/FOG
	var skyBoxGeometry = new THREE.CubeGeometry( 100, 100, 100 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xeeeeee, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
  skyBox.flipSided = true; // render faces from inside of the cube, instead of from outside (default).
	scene.add(skyBox);
	scene.fog = new THREE.FogExp2( 0xeeeeee, 1 );
	
	
	////////////
	// CUSTOM //
	////////////
	
	var cubeGeometry = new THREE.CubeGeometry( 50, 50, 50, 20, 20, 20 );
	var discTexture = THREE.ImageUtils.loadTexture( 'disc.png' );
	
	// values that are constant for all particles during a draw call
	this.customUniforms = 
	{
		time:	 { type: "f", value: 1.0 },
		texture: { type: "t", value: discTexture },
	};
	
	// properties that may vary from particle to particle. only accessible in vertex shaders!
	//	(can pass color info to fragment shader via vColor.)
	var customAttributes = 
	{
		customColor:	 { type: "c", value: [] },
		customFrequency: { type: 'f', value: [] },
		customSize: { type: 'f', value: [] }
	};
	
	

   
   $.getJSON( "LOGFILE_15.json", function( data ) {
       pointData = data;
       check();
       
   });   

          
   function check() {
        particlesCount = Math.floor(Object.size(pointData.points) / 3);
			
				//positions = new Float32Array( particlesCount * 3 );
				//colors = new Float32Array( particlesCount * 3 );

				var color = new THREE.Color();
	
				
     for ( var i = 0; i < particlesCount * 3; i += 3 ) {
       
       	// Eliminate zero dots
				if(y + x + z == 0){ 
				  continue;
					y = 500000;
					x = 500000;
					z = 500000;
					zeroCounter ++;
				}
				
       vertexCounter ++;

       if(pointData.points[i] == undefined && i <=  particlesCount * 3){
					console.log("something is wrong in the data at: " + i);
					continue;
       }


				// Point on XZ Plane
				var x = pointData.points[i].x * Math.cos(pointData.points[i].y*(Math.PI/180));
				var y = 0;
				var z = pointData.points[i].x * Math.sin(pointData.points[i].y*(Math.PI/180));
				
				var angle = (map(pointData.points[i].z, 212, 812, 0, 180))*(Math.PI/180);
				
				//Translate Point
				 x -= 40 * Math.cos(angle);
				 y -= 40 * Math.sin(angle);
				 z -= 0;
				
				// Rotate Point around Z Axis
				x1 = x * Math.cos(angle) - y * Math.sin(angle);
				y1 = x * Math.sin(angle) + y * Math.cos(angle);
				z1 = z;
				

				//positions[ i ]     = y1 * .1;
				//positions[ i + 1 ] = x1 * .1;
				//positions[ i + 2 ] = z1 * .1;

				var colorMapR = map(pointData.points[i].x, 0, 8000, .5, 0);
				var colorMapG = map(pointData.points[i].x, 0, 3000, 0, .5);
				var colorMapB = map(pointData.points[i].x, 0, 8000, .5, 0);


        var newColor = new THREE.Color( 0xffffff );
        newColor.setRGB(colorMapR,colorMapG,colorMapB);
        
				//colors[i]= newColor;

        
        particleGeo.vertices.push(
           new THREE.Vector3( y1 * 0.001, 	x1 * 0.001, 	z1 * 0.001)                
        );
        
        customAttributes.customColor.value[ vertexCounter-1] = newColor;
        customAttributes.customSize.value[ vertexCounter-1] =  map(pointData.points[i].x, 0, 5000, 0, 1);

			}
		

    	var shaderMaterial = new THREE.ShaderMaterial( 
    	{
    		uniforms: 		customUniforms,
    		attributes:		customAttributes,
    		vertexShader:   document.getElementById( 'vertexshader' ).textContent,
    		fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
    		transparent: true, alphaTest: 0.5,  // if having transparency issues, try including: alphaTest: 0.5, 
    		// blending: THREE.AdditiveBlending, depthTest: false,
    	});
    	
    	
      var particleCube = new THREE.ParticleSystem( particleGeo, shaderMaterial );
    	particleCube.position.set(0, 0, 0);
    	particleCube.dynamic = true;
    	particleCube.frustrumCulled = true;
    	particleCube.sortParticles = false;
    	scene.add( particleCube );
		}

}

function animate() 
{
  requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	if ( keyboard.pressed("z") ) 
	{ 
		// do something
	}
	
	controls.update();
	stats.update();
	
	var t = clock.getElapsedTime();
	customUniforms.time.value = t;
}

function render() 
{
	renderer.render( scene, camera );
}

</script>

</body>
</html>