<!doctype html>
<html lang="en">
<head>
	<title>Highlight</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body style="overflow:hidden;">


<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/jquery-2.1.1.min.js"></script>
<script src="js/cleanMesh.js"></script>
<script src="js/cutout.js"></script>
<script src="js/FileSaver.min.js"></script>

<!--Copyright (C) 2012 Philipp Sackl, envis precisely GmbH-->
<script type="text/javascript" charset="utf-8" src="js/THREE2STL.js"></script>

<script type="text/javascript" src="js/BinaryLoader.js"></script>
<script type="text/javascript" src="js/STLLoader.js"></script>

<script type="text/javascript" src="js/BoxGeometry.js"></script>
<script type="text/javascript" src="js/TorusGeometry.js"></script>
<script type="text/javascript" src="js/DodecahedronGeometry.js"></script>






<div id = "overlay">

</div>

<div id ="info_ghost">
</div>
<div id ="info">
		<div id ="scroller">
			<div id ="info_content">

				<div id="headline">
					HIGHLIGHT
				</div>
			
				<div class='embed-container'><iframe src='https://player.vimeo.com/video/127637897' frameborder='0' webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe></div>
			
				<div id="text_content">
					Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.   

					Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.   

					Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.   

					Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.   

					Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis.   

					At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, At accusam aliquyam diam diam dolore dolores duo eirmod eos erat, et nonumy sed tempor et et invidunt justo labore Stet clita ea et gubergren, kasd magna no rebum. sanctus sea sed takimata ut vero voluptua. est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat.   

					Consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus.   

					Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.   

					Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.   

					Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.   

					Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo

					</div>
			</div>
	</div>
	<div id="active_button">

	</div>
</div>



<span title="drag&drop data from scanner here"><div id="drop_zone" >Drop files here</div></span>

<span title="optimize scan data">
	<div id="optimize" >
		Optimize
	</div>
</span>

<span title="generate 3D printable geometry">
	<div id="create" >
		Create Lamp
	</div>
</span>

<span title="switch example scan">
	<div id="switch" >
		Switch Room
	</div>
</span>


<div id="ThreeJS" style="position: absolute; left:0px; top:0px; z-index: 0;"></div>




<!-- Custom shaders for particle effects -->
<script type="x-shader/x-vertex" id="vertexshader">
uniform float time;
attribute float customFrequency;
attribute float customSize;
attribute vec3 customColor;
varying vec3 vColor;
void main() 
{
	vColor = customColor; // set color associated to vertex; use later in fragment shader
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = sin(time) * customSize * 8.0 * ( 10.0 / length( mvPosition.xyz ) );
	gl_Position = projectionMatrix * mvPosition;
}
</script>


	
<script type="x-shader/x-fragment" id="fragmentshader">
uniform sampler2D texture;
varying vec3 vColor; // colors associated to vertices; assigned by vertex shader
void main() 
{
	// calculates a color for the particle
	gl_FragColor = vec4( vColor, 1.0 );
	// sets particle texture to desired color
	gl_FragColor = gl_FragColor;
}
</script>
<!-- end of custom shaders -->


<!-- jQuery code to display an information button and box when clicked. -->
<!-- <script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<script src="js/info.js"></script> -->






<script>

// MAIN

infoActive = true;
infoActiveCounter = 0;
sceneBuilt = false;

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
var cameraOld;

// global variables
var cube;
var zeroCounter = 0;
var particleGeo = new THREE.Geometry();
var vertexCounter = 0;
var vertexCounter1 = 0;
var vertexCounterSize = 0;
var deleteCounter = 0;
var mouseCoord = new THREE.Vector3(0,0,0);
var mouseOpacity = 0;
var mouseHold = false;
var mouseCounter = 0;

var positions = new Float32Array( 1000);
var colors;
var sizes;
var cutMeshData;
var deleteArray;

var skipCounter;

var finalPoints;



var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
direction = new THREE.Vector3( 1, 0, 0 );

var cameraVector = new THREE.Vector3( 0, 0, -1 );
var new_pos = new THREE.Vector3( 0, 0, 0 );
var new_pos2 = new THREE.Vector3( 0, 0, 0 );
var raycaster;
var planeZ = new THREE.Plane(cameraVector, 0);

var logText;

//var Ico;
var selectedMesh = new THREE.Geometry();2
var toDelete = [];
var newLampGeo = new THREE.Geometry();
var newLampMesh;

var icoVertices;

var stlName = "room3_opti.stl";

var stlNames = ["room3_opti.stl","Hybrid.stl","Hybrid2.stl","room1_opti.stl"];
var stlNameCounter = 0;

//var hole = [17,23,24,25,28,29,33,34,35,36,37,41];

// Settings
var extrude = 1.2;
// 1.6;
var thickness = .3;
var tipThickness = .1;
var holeFactor = .25;
var recursions = 4;

var doMark = false;


var isMobile = false; //initiate as false

// device detection

var isMobile = false; //initiate as false

// device detection
if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
    || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) isMobile = true;

//if((/iPhone|iPod|Android|BlackBerry/).test(navigator.userAgent)) isMobile = true;


if(!isMobile){
	init();
	animate();

} else {

		$("#active_button").hide();
		$("#active_button").css("pointer-events: none");
	    $("#optimize").css("display","none");
		$("#create").css("display","none");
		$("#switch").css("display","none");
		$("#drop_zone").css("display","none");

		//  // Disable overscroll / viewport moving on everything but scrollable divs
	 // $('body').on('touchmove', function (e) {
	 //         if (!$('.scrollable').has($(e.target)).length) e.preventDefault();
	 // });
}


// FUNCTIONS
 	
function map(x,a,b,c,d){
		return (x-a)/(b-a) * (d-c) + c;
}
	
	
Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};


// Declare webworker
var worker;
var cutoutWorker;

function startWebworker(){
	 worker = new Worker('js/cleanMesh.js');

	worker.addEventListener('message', function(e) {

		cutMeshData = e.data;
		deleteArray = cutMeshData;
		//console.log(e.data);
		console.log("mesh cleaned");
		scene.remove(particleSystem);
		particleGeo = new THREE.Geometry();
		createMesh();

		exportGeometry();

		//stlFromGeometry( particleGeo, {download:false});
		//console.log('Worker said: ', e.data);
		

	}, false);

	worker.postMessage(positions); // Send data to our worker.

}



function startCutOutWebworker(){
	 	cutoutWorker = new Worker('js/cutout.js');

	cutoutWorker.addEventListener('message', function(e) {

	updateSphere(e.data);
		//console.log('Worker said: ', e.data);
		//console.log(e.data.length);
		

	}, false);

	postToCutOutWorker();
}


 


	
function init(){

	var reader = new FileReader();

	
  function handleDragOver(evt) {

    evt.stopPropagation();
    evt.preventDefault();
    evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.

  }

	function handleFileSelect(evt) {

	if(worker != undefined){
		worker.terminate();
	}

	if(cutoutWorker != undefined){
		cutoutWorker.terminate();
	}
  	

  	//startWebworker();

    evt.stopPropagation();
    evt.preventDefault();

    var files = evt.dataTransfer.files; // FileList object.
    
    //if(files[0].type == "")

    var name = files[0].name;
    var ending = name.substr(name.length-3,3);

    if(ending == "stl"){

    	stlName = name;

    	loadSTL();

    }else if(ending == "txt"){
		// files is a FileList of File objects. List some properties.
	    var output = [];

	    reader.onload = function(e) {
	  		logText = reader.result;
	  		//console.log(logText);
	  		loadTXT();
		}

	    reader.readAsText(files[0]);

    } else {
    	alert("correct file ending?")
    }
   

  }


  // Setup the dnd listeners.
  var dropZone = document.getElementById('drop_zone');
  dropZone.addEventListener('dragover', handleDragOver, false);
  dropZone.addEventListener('drop', handleFileSelect, false);

	// SCENE
	scene = new THREE.Scene();
	
	projector = new THREE.Projector();
	
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.z = 170;
	camera.lookAt(scene.position);	
	
	// RENDERER

	renderer = new THREE.WebGLRenderer( {antialias:true} );

	renderer.setSize( window.innerWidth, window.innerHeight );
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	$( document ).ready(function(){
    	$(window).keypress(onKeyDown);
    	$(window).mousemove(onMouseMove);
    	//$(window).mousedown(function(event){mousedown()});
   
    	$(window).mousedown(function(event) {
		    switch (event.which) {
		        case 1:
		            
				    mouseHold = true;
					mouseOpacity = 0;
					mouseCounter = 0;
				 	updatePointerColor(mouseOpacity);
		            break;

		        case 3:
		        	
		        		doMark = true;
		        	

		            break;
		    }
		});

		$(window).mouseup(function(event) {
		    switch (event.which) {

		        case 3:

		        	
		        		doMark = false;
		      
		            break;
		    }
		});
    	
    	$("#optimize").click(function() {
    		alert("The data is getting cleaned. This may take several minutes - up to hours. After the process is finished, a clean .stl file will be available for downloading.");
  			startWebworker();
		});

		$("#create").click(function() {
  			startCutOutWebworker();
		});

		$("#switch").click(function() {
  			switchModel();
		});


		$("#active_button").click(function() {
			$("#info").addClass("transitionLeft");

			if(infoActive){
				var windowWith = $("#overlay").width();
				$("#info").css("left",""+  -$("#info_ghost").width()*2-$("#info_ghost").offset().left*2-60 +"px");
				$("#overlay").css("opacity","0");
				$("#overlay").css("pointer-events", "none");

				infoActiveCounter = 0;
				infoActive = false;
			} else {

				$("#info").css("left","0px");
				$("#overlay").css("opacity",".8");
				$("#overlay").css("pointer-events", "auto");

		
				infoActive = true;
			}
	    	
		});

  	});

	window.addEventListener( 'resize', onWindowResize, false );

	
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	// STATS
	// stats = new Stats();
	// stats.domElement.style.position = 'absolute';
	// stats.domElement.style.top = '0px';
	// stats.domElement.style.zIndex = 100;
	// container.appendChild( stats.domElement );
	
	// LIGHT
   var light = new THREE.PointLight(0xffffff);
   light.position.set(0,2000,0);
   scene.add(light);

   var light = new THREE.PointLight(0xffffff);
   light.position.set(1000,-1000,0);
   scene.add(light);


	
	// SKYBOX/FOG
	var newColor = new THREE.Color( );
       	//newColor.setRGB(0.9,0.9,0.9);
        newColor.setRGB(0.3,0.3,0.3);
  
	var skyBoxGeometry = new THREE.CubeGeometry( 15000, 15000, 15000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: newColor, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
    skyBox.flipSided = true; // render faces from inside of the cube, instead of from outside (default).
	scene.add(skyBox);
	

	// Mouse
	
	var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: 0.9 } );
	 
	var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
	var pointer = new THREE.Mesh( mouseGeo, pointerMaterial );

	pointer.name = "pointer";
	pointer.position.x = 10;
	pointer.position.y = 10;
	pointer.position.z = 10;
	pointer.updateMatrix();
	pointer.matrixAutoUpdate = false;
	scene.add( pointer );


  
	///////////////////
	// CUSTOM  SHADER//
	///////////////////

	var shaderMaterial;
	var particleSystem;

	//var cubeGeometry = new THREE.CubeGeometry( 50, 50, 50, 20, 20, 20 );
	//var discTexture = THREE.ImageUtils.loadTexture( 'disc.png' );

	// values that are constant for all particles during a draw call
	this.customUniforms = 
	{
		time:	 { type: "f", value: 1.0 }
		
	};

	// properties that may vary from particle to particle. only accessible in vertex shaders!
	//	(can pass color info to fragment shader via vColor.)
	
	this.customAttributes = 
	{
		customColor:	 { type: "c", value: [] },
		customFrequency: { type: 'f', value: [] },
		customSize: { type: 'f', value: [] }
	};
		
 	createSphere(); 
 	  
  	loadSTL();
  
  	// loadTXT();


	// $.ajax({
 //            url : "data/livingRoom2.txt",
 //            dataType: "text",
 //            success : function (data) {
 //            	logText = data;
 //            	//startWebworker();
 //            	loadTXT();
 //            }
 //    });


}


function loadSTL(file){
	var loader = new THREE.STLLoader();

				loader.addEventListener( 'load', function ( event ) {
					
					particleGeo = event.content;

					particlesCount = particleGeo.vertices.length;

					for (var i =  0; i < particlesCount ; i++) {
						

						var pos = new THREE.Vector3(particleGeo.vertices[i].x,particleGeo.vertices[i].y,particleGeo.vertices[i].z);


						var subVector = new THREE.Vector3(0,0,0);
						subVector = pos.sub(new THREE.Vector3(0,0,0));

						var distance = subVector.length();


						var colorMapR = map(distance, 0, 300, .6, 0);
						var colorMapG = map(distance, 0, 300, 0, .5);
						var colorMapB = map(distance, 0, 300, .5, .2);


				        var newColor = new THREE.Color( );
				        newColor.setRGB(1,1,1);


						customAttributes.customColor.value[ i ] = newColor;
        				customAttributes.customSize.value[ i ] =  map(distance, 0, 300, 0, 5);
        				customAttributes.customSize.value[ i ] =  10;

					};

					customAttributes.customColor.needsUpdate = true;
	 				customAttributes.customSize.needsUpdate = true;

					
					addToScene();
				} );


				loader.load( 'data/' + stlName + '' );
				//loader.load(file);
				//loader.load( 'data/room.stl' );

}


function loadTXT(){

	var regFileComplete = /(A|O)/g;

	var counter = 0;

	//vertexCounter = 0;

	// Search for beginning and end in file
	while ((match = regFileComplete.exec(logText)) != null) {
		counter ++;
	}

	if(counter == 2){

		console.log("correct file detected");

		var data = logText.substr(1,logText.length-2);

		//console.log("data: " + data);
		


	//Parser - Get Points

		var regPP = /(P)/g;
		var ppArray = [2];

		var pointsIndex = [];
		var pointCounter = 0; 

		finalPoints = [];


		while ((match = regPP.exec(data)) != null) {

			pointsIndex.push(match.index);
			
			}

			for (var i = 0; i < pointsIndex.length; i++) {
				ppArray[0] = pointsIndex[i];
				ppArray[1] = pointsIndex[i+1];



				if(i % 2 == 0){

					var newPointTXT = new THREE.Vector3(0,0,0);

					var pointValid = false;

					var point = data.substr(ppArray[0]+1,(ppArray[1])-(ppArray[0]+1));

					//Get X Value
						var regXX = /(x)/g;
						var xxArray = [2];
						counter = 0;
						while ((match = regXX.exec(point)) != null) {
							
							if(counter < 3){
								xxArray[counter] =  match.index;
								counter ++;
							}

						}

						var x = point.substr(xxArray[0]+1,xxArray[1]-(xxArray[0]+1));
						
						if( x.length > 0 ){
							//Valid Value
							newPointTXT.x = x;

							pointValid = true;
						} else {
							pointValid = false;
						}


					//Get Y Value
						var regYY = /(y)/g;
						var yyArray = [2];

						counter = 0;

						while ((match = regYY.exec(point)) != null) {
	
							if(counter < 3){
								yyArray[counter] =  match.index;
								counter ++;
							}

						}

						var y = point.substr(yyArray[0]+1,yyArray[1]-(yyArray[0]+1));
						
						if( y.length > 0 ){
							//Valid Value
							newPointTXT.y = y;

							pointValid = true;
						} else {
							pointValid = false;
						}


						


					//Get Z Value

						var regZZ = /(z)/g;
						var zzArray = [2];
						counter = 0;
						while ((match = regZZ.exec(point)) != null) {
							
							if(counter < 3){
								zzArray[counter] =  match.index;
								counter ++;
							}

						}

						var z = point.substr(zzArray[0]+1,zzArray[1]-(zzArray[0]+1));
						
						if( z.length > 0 ){
							//Valid Value
							newPointTXT.z = z;

							pointValid = true;
						} else {
							pointValid = false;
						}


						if(pointValid && (newPointTXT.x + newPointTXT.y) != 0){

							finalPoints.push(newPointTXT);

						}


				}

				
			}
	}


	// Create Point List

	particlesCount = finalPoints.length;

	var color = new THREE.Color();
	
	positions = new Float32Array( particlesCount * 3 );
	colors = new Float32Array( particlesCount * 3);
	sizes = new Float32Array( particlesCount );
	deleteArray = new Int32Array( particlesCount );
	
	vertexCounter = -1;


     for ( var i = 0; i < particlesCount * 3; i += 3 ) {
       
       vertexCounter ++;

		// Point on XZ Plane
		var x = finalPoints[vertexCounter].x * Math.cos(finalPoints[vertexCounter].y*(Math.PI/180));
		var y = 0;
		var z = finalPoints[vertexCounter].x * Math.sin(finalPoints[vertexCounter].y*(Math.PI/180));

		

		// Eliminate zero dots
		if(y + x + z == 0){ 
	    	continue;
		}

		var angle = (map(finalPoints[vertexCounter].z, 175, 805, -5, 175))*(Math.PI/180);
	

		//Translate Point
		 x -=  3 * Math.cos(angle) * (finalPoints[vertexCounter].x * .003); 
		 y -=  3 * Math.sin(angle) * (finalPoints[vertexCounter].x * .003);
		 z -= 0;
		
		// Rotate Point around Z Axis
		x1 = x * Math.cos(angle) - y * Math.sin(angle);
		y1 = x * Math.sin(angle) + y * Math.cos(angle);
		z1 = z;
		
		var distance = finalPoints[vertexCounter].x;
		
		var colorMapR = map(distance, 0, 3000, .6, 0);
		var colorMapG = map(distance, 0, 3000, 0, .5);
		var colorMapB = map(distance, 0, 3000, .5, .2);


        var newColor = new THREE.Color( );
        newColor.setRGB(1,1,1);

       	// Eliminate zero dots
		if(y1 + x1 + z1 == 0){ 
	    	continue;
		}
        
    positions[ i ]     = y1 * -.1;
	positions[ i + 1 ] = (x1 * -.1) - 10;
	positions[ i + 2 ] = z1 * .1;
		
	colors[ i ]     = newColor.r;
	colors[ i + 1 ] = newColor.g;
	colors[ i + 2 ] = newColor.b;
		
	sizes[ vertexCounter] =  map(finalPoints[vertexCounter].x, 0, 3000, 0, 10);

	

	}
		  
		

	//	console.log(positions.length)
		createMesh();

}

function createSphere(){

	var pinkMat = new THREE.MeshPhongMaterial({
		  color      :  new THREE.Color("rgb(100,100,100)"),
		  emissive   :  new THREE.Color("rgb(150,150,150)"),
		  specular   :  new THREE.Color("rgb(155,155,155)"),
		  shininess  :  10,
		  shading    :  THREE.FlatShading,
		  side       : 	THREE.DoubleSide,
		  transparent: 	0,
		  opacity    : 	1,
		  wireframe	 : 	false
		});

	// var loader = new THREE.STLLoader();
	// loader.addEventListener( 'load', function ( event ) {
		
	// 	var bulbGeo = event.content;



	// 	// var icoMaterial =  new THREE.MeshPhongMaterial( { color:new THREE.Color("rgb(255,255,255)"), shading:  THREE.FlatShading, side: THREE.DoubleSide} );


	// 	bulbGeo.computeCentroids();
	// 	bulbGeo.computeFaceNormals();
	// 	bulbGeo.computeVertexNormals(); 


	// 	Ico = new THREE.Mesh(bulbGeo, pinkMat);
	// 	Ico.dynamic = true;
	// 	Ico.doubleSided = true;

	// 	scene.add(Ico);


	// 	//addToScene();
	// } );
	// loader.load( 'data/ico3.stl' );





	Ico = new THREE.Mesh(new THREE.IcosahedronGeometry(7.5,2), pinkMat);
	Ico.dynamic = true;
	Ico.doubleSided = true;


	var lampGeo = new THREE.Geometry();

	for (var i = 0; i <= Ico.geometry.vertices.length - 1; i++) {

			lampGeo.vertices.push(Ico.geometry.vertices[i]);
			
	}

	for (var i = 0; i <= Ico.geometry.faces.length - 1 ; i++) {

			// var leaveOut = false;

			// for (var j = hole.length - 1; j >= 0; j--) {
			// 	if(hole[j] == i){
			// 		leaveOut = true;
			// 	}

			// };

			// // if( i < 40){
			// // 	leaveOut = true;
			// // }
			// if(!leaveOut){
				lampGeo.faces.push(Ico.geometry.faces[i]);
			// }
			
			
	}

		lampGeo.computeCentroids();
		lampGeo.computeFaceNormals();
		lampGeo.computeVertexNormals(); 

	Ico = new THREE.Mesh(lampGeo, pinkMat);

	scene.add(Ico);
	



}


function updateSphere(cutMeshData){


		newLampGeo = new THREE.Geometry();

		//console.log(cutMeshData);

		//Draw debug boxes

		// var geometry = new THREE.BoxGeometry( .1, .1, .1 );
		// var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); 
		// var cube = new THREE.Mesh( geometry, material );

		if(cutMeshData[2] != undefined){
			for(var i = 0; i <= cutMeshData[2].length -3; i +=3){

				var cube = new THREE.Mesh( geometry, material );
				cube.position = new THREE.Vector3(cutMeshData[2][i],cutMeshData[2][i+1],cutMeshData[2][i+2]);
					scene.add( cube );

			}

		}


		for (var i = 0; i <= cutMeshData[0].length - 3 ; i+=3) {

			newLampGeo.vertices.push(new THREE.Vector3(cutMeshData[0][i],cutMeshData[0][i+1],cutMeshData[0][i+2]));
			
		}


		//	var scaleFactor = 7.5;
		var scaleFactor = 10;
		
		var exportGeo = new THREE.Geometry();

		for (var i = 0; i <= cutMeshData[0].length - 3 ; i+=3) {

			exportGeo.vertices.push(new THREE.Vector3(cutMeshData[0][i]*scaleFactor,cutMeshData[0][i+1]*scaleFactor,cutMeshData[0][i+2]*scaleFactor));
			
		}

		for (var i = 0; i <= cutMeshData[1].length - 3 ; i+=3) {
			newLampGeo.faces.push(new THREE.Face3(cutMeshData[1][i],cutMeshData[1][i+1],cutMeshData[1][i+2]));
		}

		for (var i = 0; i <= cutMeshData[1].length - 3 ; i+=3) {
			exportGeo.faces.push(new THREE.Face3(cutMeshData[1][i],cutMeshData[1][i+1],cutMeshData[1][i+2]));
		}


		newLampGeo.computeCentroids();
		newLampGeo.computeFaceNormals();
		newLampGeo.computeVertexNormals(); 

		exportGeo.computeCentroids();
		exportGeo.computeFaceNormals();
		exportGeo.computeVertexNormals(); 


		//Export STL
		var stl = stlFromGeometry( exportGeo, {download:false});

		var blob = new Blob([stl], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "sphere.stl");
		
		var pinkMat = new THREE.MeshPhongMaterial({
		  color      :  new THREE.Color("rgb(100,100,100)"),
		  emissive   :  new THREE.Color("rgb(150,150,150)"),
		  specular   :  new THREE.Color("rgb(155,155,155)"),
		  shininess  :  10,
		  shading    :  THREE.FlatShading,
		  side       : 	THREE.DoubleSide,
		  transparent: 	0,
		  opacity    : 	1,
		  wireframe	 : 	false
		});

		var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );

		newLampMesh = new THREE.Mesh(newLampGeo, pinkMat);


		newLampMesh.name = "newLampMesh";
		scene.add(newLampMesh);

		scene.remove(Ico);


}

function createMesh(){

	particleGeo = new THREE.Geometry();

	// Create Mesh
	vertexCounterSize = 0;
	vertexCounter = 0;
	skipCounter = 0;
	deleteCounter = 0;
	
     // for(var i = 0; i < 1000; i+=3){  
	for(var i = 0; i < positions.length; i+=3){  


		var newPoint = new THREE.Vector3( positions[ i ],	positions[ i + 1 ] , positions[ i + 2 ]);  
		 
		
		if(deleteArray[deleteCounter] == 1){
		   deleteCounter ++;
		   skipCounter ++;
		   vertexCounterSize++;
		   continue;
		   //console.log("skip");
		}else{
			//console.log("not so skip");
		}

		if(newPoint.x + newPoint.y + newPoint.z == 0){
		   deleteCounter ++;
		   skipCounter ++;
		   vertexCounterSize++;
		   continue;
		} 

		if(vertexCounter % 3 == 0 || vertexCounter == 0){
			if(vertexCounter-1 != -1){
				 particleGeo.faces.push( new THREE.Face3(vertexCounter, vertexCounter+1, vertexCounter-1));
			}else{
				particleGeo.faces.push( new THREE.Face3(vertexCounter, vertexCounter+1, vertexCounter+2));
			}
			   
		}

		deleteCounter ++;
		vertexCounter ++;
		vertexCounterSize++;
		        
		particleGeo.vertices.push(
		   newPoint                
		);


		var newColor = new THREE.Color();
		newColor.setRGB(	colors[ i ], 	colors[ i + 1 ], 	colors[ i + 2 ] );
		customAttributes.customColor.value[ vertexCounter-1] = newColor;
		customAttributes.customSize.value[ vertexCounter-1] =  sizes[vertexCounterSize-1];;


	}

       customAttributes.customColor.needsUpdate = true;
	   customAttributes.customSize.needsUpdate = true;
      
	//   console.log("skipped: " + skipCounter);

       addToScene();

}

function addToScene(){


		if(scene.getObjectByName("particleSystem") != undefined){
			scene.remove(particleSystem);
		}

		this.shaderMaterial = new THREE.ShaderMaterial( 
		{
			uniforms: 		customUniforms,
			attributes:		customAttributes,
			vertexShader:   document.getElementById( 'vertexshader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
			transparent: true,
			alphaTest: 0.5
		});
			

			
		this.particleSystem = new THREE.ParticleSystem( particleGeo, this.shaderMaterial );
		this.particleSystem.position.set(0, 0, 0);
		this.particleSystem.dynamic = true;
		this.particleSystem.frustrumCulled = true;
		this.particleSystem.sortParticles = false;
		this.particleSystem.name = "particleSystem";
		scene.add( this.particleSystem );	

		sceneBuilt = true;


}

function switchModel(){
	
	stlNameCounter ++;

	if(stlNameCounter >= stlNames.length){
		stlNameCounter = 0;
	}
	stlName = stlNames[stlNameCounter];
	
	loadSTL();
}

function onMouseMove(event){
  
	mouseCoord = new THREE.Vector3( (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5 );
 	
 	calcPointer();

 	

}

// function onMouseDown(event e){
// 	mouseHold = true;
// 	mouseOpacity = 0;
// 	mouseCounter = 0;
// 	updatePointerColor(mouseOpacity);

// 	switch (e.which) {
//         case 1:
//             alert('Left Mouse button pressed.');
//             break;
//         case 2:
//             alert('Middle Mouse button pressed.');
//             break;
//         case 3:
//             alert('Right Mouse button pressed.');
//             break;
//         default:
//             alert('You have a strange Mouse!');
//     }
// }

function onKeyDown(event) {


		// Space Bar
			if(event.charCode == 32){
				markPoints();
			}

				

    
};

function markPoints(){
	//selectedMesh = new THREE.Geometry();

				for ( var i = 0; i < particleGeo.vertices.length; i ++ ) {
              
		            var vertex = particleGeo.vertices[i];
		             
		              //Get the current camera position  
		            new_pos.copy(camera.position);
		             
		             //Get the smallest distance to the cube and if the distance is smaller than
		             // the distance from camera to cube divided by ten (imaginary contact with sphere),
		             // change the color
		            if(raycaster.ray.distanceToPoint(vertex) <= new_pos.sub(vertex).length()/20 ){
		                  
		                  

		                var newColor = new THREE.Color( );
       					
       					newColor.setRGB(.9,.8,.2);

		                
		                customAttributes.customColor.value[ i ] = newColor;
		                customAttributes.customSize.value[ i ] = 25;
		                  
		                  

   		                selectedMesh.vertices.push(vertex);
		                  
		                  


			            var material = new THREE.LineBasicMaterial({color: newColor, opacity: .5 });

			            material.transparent = true;

						var geometry = new THREE.Geometry();
						geometry.vertices.push(
							new THREE.Vector3( 0, 0, 0 ),
							vertex
						);

						var line = new THREE.Line( geometry, material );
					//	scene.add( line );

		                  
						customAttributes.customColor.needsUpdate = true;
						customAttributes.customSize.needsUpdate = true;

	              	}
	              
	            }
	        
}

function postToCutOutWorker(){
	 // Convert Mesh data into ArrayBuffer for Webworker

	        	var selecteMeshBuffer = new Float32Array( selectedMesh.vertices.length * 3);
	          	var icoVertices = new Float32Array((Ico.geometry.vertices.length - 0) * 3);
	          	var icoFacesCentroids = new Float32Array((Ico.geometry.faces.length -0) * 3);
	          	var icoFaces = new Float32Array((Ico.geometry.faces.length -0) * 3);


	        	var vertexCounter = 0;
		        for (var i = 0; i <= selecteMeshBuffer.length - 3; i+=3) {
		        	selecteMeshBuffer[i] =   selectedMesh.vertices[vertexCounter].x;
		          	selecteMeshBuffer[i+1] = selectedMesh.vertices[vertexCounter].y;
		          	selecteMeshBuffer[i+2] = selectedMesh.vertices[vertexCounter].z;
		          	vertexCounter++;
		        };

	          	var vertexCounter = 0;
		        for (var i = 0; i <= icoVertices.length - 3; i+=3) {
					icoVertices[i] =   Ico.geometry.vertices[vertexCounter].x;
	         	 	icoVertices[i+1] = Ico.geometry.vertices[vertexCounter].y;
	          		icoVertices[i+2] = Ico.geometry.vertices[vertexCounter].z;

		          	vertexCounter++;   	
		        };

		        var vertexCounter = 0;
		        for (var i = 0; i <= icoFaces.length - 3; i+=3) {
		        	// if(vertexCounter == 0){
		        	// 	icoFacesCentroids[i] =   0;
		         //  		icoFacesCentroids[i+1] = 0;
		         //  		icoFacesCentroids[i+2] = 0;
		        	// }else{


		          	icoFacesCentroids[i] =   Ico.geometry.faces[vertexCounter].centroid.x;
		          	icoFacesCentroids[i+1] = Ico.geometry.faces[vertexCounter].centroid.y;
		          	icoFacesCentroids[i+2] = Ico.geometry.faces[vertexCounter].centroid.z;
		          	// }
		          	vertexCounter++;
		        };

				var vertexCounter = 0;
		        for (var i = 0; i <= icoFaces.length - 3; i+=3) {
		        	// if(vertexCounter == 0){
		        	// 	icoFaces[i] =   0;
		         //  		icoFaces[i+1] = 0;
		         //  		icoFaces[i+2] = 0;
		        	// } else {


		          	icoFaces[i] =   Ico.geometry.faces[vertexCounter].a;
		          	icoFaces[i+1] = Ico.geometry.faces[vertexCounter].b;
		          	icoFaces[i+2] = Ico.geometry.faces[vertexCounter].c;
		         	// }
		          	vertexCounter++;
		        };



        		var buffers = [ selecteMeshBuffer, icoVertices, icoFacesCentroids, icoFaces, extrude, thickness, recursions, tipThickness, holeFactor];

        		//console.log(buffers);
        		//console.log(selecteMeshBuffer);
         		cutoutWorker.postMessage(buffers);
}

function calcPointer(){

	// Create Camera Vector
  cameraVector.applyQuaternion( camera.quaternion );
   
	mouseX = mouseCoord.x;

	//New Projector Class picking ray
   raycaster = projector.pickingRay(mouseCoord, camera);

   var pos = raycaster.ray.intersectPlane(planeZ);


     // Position object near camera - move it along vector between camera and calculated
     // pos
		
		 if(pos != null){
			 new_pos2.copy(pos);  
			}


     new_pos2.sub(camera.position);


     new_pos2.normalize();
     new_pos2.multiplyScalar(20);

     new_pos2.add(camera.position);

     object = scene.getObjectByName( "pointer" );


     object.position.set(new_pos2.x,new_pos2.y,new_pos2.z);
     object.updateMatrix();
}

function exportGeometry(){
	var stl = stlFromGeometry( particleGeo, {download:false});

	var blob = new Blob([stl], {type: "text/plain;charset=utf-8"});
	saveAs(blob, "room.stl");
}

function updatePointerColor(opacity){
	//console.log("update color");
	var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: opacity } );

	scene.getObjectByName( "pointer" ).material = pointerMaterial;
	scene.getObjectByName( "pointer" ).material.needsUpdate = true;
}

function checkCamera(){
 if(camera.quaternion.x == cameraOld){
    //console.log("change");
   // mouseHold = true;
  // scene.getObjectByName( "pointer" ).visible = true;
    //calcPointer();
  } else {
     mouseHold = true;
	 mouseOpacity = 0;
	 mouseCounter = 0;
	 updatePointerColor(mouseOpacity);
     
 }
  
 cameraOld = camera.quaternion.x;
}

function animate(){



 requestAnimationFrame( animate );

 if(infoActiveCounter > 10){
	return;
}


	render();		
	update();

if(infoActive && sceneBuilt){
	infoActiveCounter ++;
}

}

function update(){


//console.log(mouseOpacity);
	
	if(mouseOpacity >= 1){
		mouseHold = false;
	}

	if ( mouseHold) 
	{ 	
		if(mouseCounter <= 1){
			mouseCounter += .01;
		}
		
		if(mouseCounter > .5){
			mouseOpacity += .1;

			updatePointerColor(mouseOpacity);
		}
		
	}

	if(doMark){
		markPoints();
	}
	

	

	controls.update();
	//stats.update();
    //checkCamera();
	//var t = clock.getElapsedTime();
	//customUniforms.time.value = 0.1;
}

function render() 
{

	renderer.render( scene, camera );
}
function onWindowResize() {

	if(!infoActive){
		
		$("#info").removeClass("transitionLeft");
		$("#info").css("left",""+  -$("#info_ghost").width()*2 -$("#info_ghost").offset().left*2-60 +"px");

	}
	
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );


}
</script>

</body>
</html>