<!doctype html>
<html lang="en">
<head>
	<title>Highlight</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="style.css">
	<link href='http://fonts.googleapis.com/css?family=Lato:400,100,100italic' rel='stylesheet' type='text/css'>
	<link href='http://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300' rel='stylesheet' type='text/css'>
</head>
<body style="overflow:hidden;">


<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/jquery-2.1.1.min.js"></script>
<script src="js/cleanMesh.js"></script>
<script src="js/cutout.js"></script>
<script src="js/FileSaver.min.js"></script>

<!--Copyright (C) 2012 Philipp Sackl, envis precisely GmbH-->
<script type="text/javascript" charset="utf-8" src="js/THREE2STL.js"></script>

<script type="text/javascript" src="js/BinaryLoader.js"></script>
<script type="text/javascript" src="js/STLLoader.js"></script>

<script type="text/javascript" src="js/BoxGeometry.js"></script>
<script type="text/javascript" src="js/TorusGeometry.js"></script>
<script type="text/javascript" src="js/DodecahedronGeometry.js"></script>






<div id = "overlay">

</div>

<div id ="info_ghost">
</div>
<div id ="info">
		<div id ="scroller">
			<div id ="info_content">

				<div id="headline">
					Rethinking Prototyping - Highlight
				</div>
			
				<div class='embed-container'><iframe src='https://player.vimeo.com/video/127637897' frameborder='0' webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe></div>
			
				<div id="text_content">
					Every space we inhabit is different: not only its’ architecture, but also the way we arrange it according to our needs. When it comes to light, one might want to have a spotlight at the couch table, illuminate a piece of art on the wall, or highlight a specific feature in the architecture of the room. With this in mind, we developed Highlight, a digital fabrication service which creates custom-designed lampshades, allowing users to direct the light to where they deem it best needed.<br>
					The era of digital fabrication brought new customization possibilities. Using algorithms, designers are able to generate products according to specific needs of users. In this line, designing objects which respond to every interior seems like an obvious step. However, this process has always remained challenging, as it requires designing new tools and systems as well as blending the physical with the digital. With this project, we address this challenge and show that with the help of technology, the designer’s aesthetic can be adapted to user’s personal needs.<br><br> 
					The system consists of three core components: a custom built 3D scanner, a web based generative software system and a 3D printing service.<br><br>
					First, the user receives a 3D scanner, which can be screwed directly into the existing lamp socket of the room and operated through the light switch. After the room is scanned, the users can see a 3D representation of the room in a web-based application. In this way, he or she can decide to which areas the light should be directed.  From these data, the shape is automatically generated and ready to be printed. Once installed in the room, the lampshade creates a special atmosphere, combining both diffused and direct lighting into one single object.<br>
					Highlight takes advantage not only of the aesthetical and functional possibilities of digital fabrication, but also presents a new paradigm as a service, bringing together the uniqueness of an atelier solution with the advantages of a mass-production process. For example, since a 3d scanner is an expensive piece of hardware, it is provided to the users in a short time loan.<br>
					Another big advantage of this service, is the fact that a 3d preview of the lamp is generated in real time. The chance to see the lamp in the real context, gives a better understanding of how the product will work than when buying it in a shop. This last point is even more important when buying 3D printable products. In this case, one cannot even see the real object, but only a model, loosing the sense of proportion and scale. Hence, by connecting the model with the space for which it is designed, the product becomes more "tangible." <br> In order to scan the room in 3d from the location of a lamp socket, we developed a custom piece of hardware. Combining Robopeak's "RPLIDAR 360 Degree Laser Scanner" with a "Dynamixel Robot Servo", it is possible to do a volumetric scan of the room. A specially designed power converter provides power supply directly from the lamp socket, enabling a cable free installation of the scanner. The Hardware is controlled by an Arduino based system with a custom software, that saves the data on an SD card for easy handling. The user can upload the data to a custom website, which converts the data into a point cloud. This serves as the basis of the user interaction - navigating a virtual representation of the room and selecting areas, that should be illuminated. The software runs on the client side and is a custom solution built with THREE.js / WebGL / HTML5. This cross platform application generates the geometry of the lamp, that can be viewed in real time and is exportable for 3D printing as an STL file.<br> The intuitive browser interface is designed to allow creativity and freedom to the users. By using a “painting tool” as an interaction affordance, users can easily focus on the desired effect. The visual quality of the 3D point cloud gives an implicit freedom to highlight the features of the space, and at the same time, provides an easy-to-operate digital environment. The scanning of the room and its visualization in 3D, serves the users as a design tool they had no access before. This gives them the chance to use their creativity and presents them with the opportunity to perceive their domestic spaces in a refreshing way.<br> From the user experience, the object has a strong narrative and performative aspect. By the process of “making”, this object becomes meaningful and personal. As a result from this, every lamp is strongly connected to the person who created it and the space where it lives in. The product is not a single object anymore, but goes beyond, including the whole process, from planning to realization.<br>In summary, the research project explores the possibilities of designing in the existing space in a tightly coupled way, where the designer’s aesthetics and the users’ needs are brought together with the help of custom hardware and software. The resulting striking and functional digitally fabricated artefact fits seamlessly in its context. The first iteration of the idea is a lampshade generator, but the concept easily translates to various other aspects of spatial design: from furniture to space dividers, wall surface materials, acoustic elements and beyond.

					</div>

					<div id="text_info">
						2015<br>
						THE BERLIN UNIVERSITY OF THE ARTS<br>
						HIGHLIGHT TEAM:<br>
						PROF. JUSSI ÄNGESLEVÄ<br>
						MICHAEL BURK<br>
						IOHANNA NICENBOIM<br><br>
						THE WORK HAS BEEN DONE AS A PART OF "RETHINKING PROTOTYPING" RESEARCH PROJECT, SUPPORTED BY<br> EINSTEIN STIFTUNG THROUGH HYBRID PLATTFORM.
					</div>
			</div>
	</div>
	<div id="active_button" >
		<div id="active_button_pen" title="Try it out"></div>
		<div id="active_button_info" title="Info"></div>
	</div>
	<div id="bottom_creeper" class="hideable">
		Try it out!
	</div>
</div>



<span title="drag&drop data from scanner here"><div id="drop_zone" class="hideable">Drop files here</div></span>

<span title="optimize scan data">
	<div id="optimize" class="hideable">
		Optimize
	</div>
</span>

<span title="generate 3D printable geometry">
	<div id="create" class="hideable">
		Create Lamp
	</div>
</span>

<span title="switch example scan">
	<div id="switch" class="hideable">
		Switch Room
	</div>
</span>


<div id="ThreeJS" style="position: absolute; left:0px; top:0px; z-index: 0;"></div>




<!-- Custom shaders for particle effects -->
<script type="x-shader/x-vertex" id="vertexshader">
uniform float time;
attribute float customFrequency;
attribute float customSize;
attribute vec3 customColor;
varying vec3 vColor;
void main() 
{
	vColor = customColor; // set color associated to vertex; use later in fragment shader
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = sin(time) * customSize * 8.0 * ( 10.0 / length( mvPosition.xyz ) );
	gl_Position = projectionMatrix * mvPosition;
}
</script>


	
<script type="x-shader/x-fragment" id="fragmentshader">
uniform sampler2D texture;
varying vec3 vColor; // colors associated to vertices; assigned by vertex shader
void main() 
{
	// calculates a color for the particle
	gl_FragColor = vec4( vColor, 1.0 );
	// sets particle texture to desired color
	gl_FragColor = gl_FragColor;
}
</script>
<!-- end of custom shaders -->


<!-- jQuery code to display an information button and box when clicked. -->
<!-- <script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<script src="js/info.js"></script> -->






<script>

// MAIN

infoActive = true;
infoActiveCounter = 0;
sceneBuilt = false;

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
var cameraOld;

// global variables
var cube;
var zeroCounter = 0;
var particleGeo = new THREE.Geometry();
var vertexCounter = 0;
var vertexCounter1 = 0;
var vertexCounterSize = 0;
var deleteCounter = 0;
var mouseCoord = new THREE.Vector3(0,0,0);
var mouseOpacity = 0;
var mouseHold = false;
var mouseCounter = 0;

var positions = new Float32Array( 1000);
var colors;
var sizes;
var cutMeshData;
var deleteArray;

var skipCounter;

var finalPoints;



var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
direction = new THREE.Vector3( 1, 0, 0 );

var cameraVector = new THREE.Vector3( 0, 0, -1 );
var new_pos = new THREE.Vector3( 0, 0, 0 );
var new_pos2 = new THREE.Vector3( 0, 0, 0 );
var raycaster;
var planeZ = new THREE.Plane(cameraVector, 0);

var logText;

//var Ico;
var selectedMesh = new THREE.Geometry();2
var toDelete = [];
var newLampGeo = new THREE.Geometry();
var newLampMesh;

var icoVertices;

var stlName = "room3_opti.stl";

var stlNames = ["room3_opti.stl","Hybrid.stl","Hybrid2.stl","room1_opti.stl"];
var stlNameCounter = 0;

//var hole = [17,23,24,25,28,29,33,34,35,36,37,41];

// Settings
var extrude = 1.2;
// 1.6;
var thickness = .3;
var tipThickness = .1;
var holeFactor = .25;
var recursions = 4;

var doMark = false;


var isMobile = false; //initiate as false

// device detection

var isMobile = false; //initiate as false

// device detection
if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
    || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) isMobile = true;

//if((/iPhone|iPod|Android|BlackBerry/).test(navigator.userAgent)) isMobile = true;


if(!isMobile){
	init();
	animate();

} else {

		$("#active_button").hide();
		$("#active_button").css("pointer-events: none");
	    $("#optimize").css("display","none");
		$("#create").css("display","none");
		$("#switch").css("display","none");
		$("#drop_zone").css("display","none");

		//  // Disable overscroll / viewport moving on everything but scrollable divs
	 // $('body').on('touchmove', function (e) {
	 //         if (!$('.scrollable').has($(e.target)).length) e.preventDefault();
	 // });
}


// FUNCTIONS
 	
function map(x,a,b,c,d){
		return (x-a)/(b-a) * (d-c) + c;
}
	
	
Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};


// Declare webworker
var worker;
var cutoutWorker;

function startWebworker(){
	 worker = new Worker('js/cleanMesh.js');

	worker.addEventListener('message', function(e) {

		cutMeshData = e.data;
		deleteArray = cutMeshData;
		//console.log(e.data);
		console.log("mesh cleaned");
		scene.remove(particleSystem);
		particleGeo = new THREE.Geometry();
		createMesh();

		exportGeometry();

		//stlFromGeometry( particleGeo, {download:false});
		//console.log('Worker said: ', e.data);
		

	}, false);

	worker.postMessage(positions); // Send data to our worker.

}



function startCutOutWebworker(){
	 	cutoutWorker = new Worker('js/cutout.js');

	cutoutWorker.addEventListener('message', function(e) {

	updateSphere(e.data);
		//console.log('Worker said: ', e.data);
		//console.log(e.data.length);
		

	}, false);

	postToCutOutWorker();
}


 


	
function init(){

	var reader = new FileReader();

	
  function handleDragOver(evt) {

    evt.stopPropagation();
    evt.preventDefault();
    evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.

  }

	function handleFileSelect(evt) {

	if(worker != undefined){
		worker.terminate();
	}

	if(cutoutWorker != undefined){
		cutoutWorker.terminate();
	}
  	

  	//startWebworker();

    evt.stopPropagation();
    evt.preventDefault();

    var files = evt.dataTransfer.files; // FileList object.
    
    //if(files[0].type == "")

    var name = files[0].name;
    var ending = name.substr(name.length-3,3);

    if(ending == "stl"){

    	stlName = name;

    	loadSTL();

    }else if(ending == "txt"){
		// files is a FileList of File objects. List some properties.
	    var output = [];

	    reader.onload = function(e) {
	  		logText = reader.result;
	  		//console.log(logText);
	  		loadTXT();
		}

	    reader.readAsText(files[0]);

    } else {
    	alert("correct file ending?")
    }
   

  }


  // Setup the dnd listeners.
  var dropZone = document.getElementById('drop_zone');
  dropZone.addEventListener('dragover', handleDragOver, false);
  dropZone.addEventListener('drop', handleFileSelect, false);

	// SCENE
	scene = new THREE.Scene();
	
	projector = new THREE.Projector();
	
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.z = 170;
	camera.lookAt(scene.position);	
	
	// RENDERER

	renderer = new THREE.WebGLRenderer( {antialias:true} );

	renderer.setSize( window.innerWidth, window.innerHeight );
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	$( document ).ready(function(){
    	$(window).keypress(onKeyDown);
    	$(window).mousemove(onMouseMove);
    	//$(window).mousedown(function(event){mousedown()});
   
    	$(window).mousedown(function(event) {
		    switch (event.which) {
		        case 1:
		            
				    mouseHold = true;
					mouseOpacity = 0;
					mouseCounter = 0;
				 	updatePointerColor(mouseOpacity);
		            break;

		        case 3:
		        	
		        		doMark = true;
		        	

		            break;
		    }
		});

		$(window).mouseup(function(event) {
		    switch (event.which) {

		        case 3:

		        	
		        		doMark = false;
		      
		            break;
		    }
		});

		var out = false;

		if(!isMobile){
			$("#info_content").scroll(function(){


				if($(this).scrollTop() + $(this).innerHeight() >= this.scrollHeight) {
           				$("#bottom_creeper").css("opacity","1");
           				out = false;
       			}

       			if($(this).scrollTop() + $(this).innerHeight() <= this.scrollHeight-100 && !out) {
           				out = true;
           				$("#bottom_creeper").css("opacity","0");
           				 
       			}
				
			});
			// document.getElementById('scroller').onscroll = function(){
			// 	console.log("scroll");
			// };
		}
		

    	
    	$("#optimize").click(function() {
    		alert("The data is getting cleaned. This may take several minutes - up to hours. After the process is finished, a clean .stl file will be available for downloading.");
  			startWebworker();
		});

		$("#create").click(function() {
  			startCutOutWebworker();
		});

		$("#switch").click(function() {
  			switchModel();
		});


		$("#active_button").click(function() {
			$("#info").addClass("transitionLeft");

			if(infoActive){
				var windowWith = $("#overlay").width();
				$("#info").css("left",""+  -$("#info_ghost").width()*2-$("#info_ghost").offset().left*2-60 +"px");
				$("#overlay").css("opacity","0");
				$("#overlay").css("pointer-events", "none");

				infoActiveCounter = 0;
				infoActive = false;

				$("#active_button_info").css("opacity",".6");
				$("#active_button_info").css("pointer-events","auto");
				$("#active_button_pen").css("pointer-events","none");
				$("#active_button_pen").css("opacity","0");
				
				$( ".hideable").css("opacity",".9");

			} else {

				$("#info").css("left","0px");
				$("#overlay").css("opacity",".8");
				$("#overlay").css("pointer-events", "auto");

				$("#active_button_info").css("opacity","0");
				$("#active_button_info").css("pointer-events","none");
				$("#active_button_pen").css("opacity",".6");
				$("#active_button_pen").css("pointer-events","auto");

				$( ".hideable").css("opacity","0");

		
				infoActive = true;
			}
	    	
		});

  	});

	window.addEventListener( 'resize', onWindowResize, false );

	
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	// STATS
	// stats = new Stats();
	// stats.domElement.style.position = 'absolute';
	// stats.domElement.style.top = '0px';
	// stats.domElement.style.zIndex = 100;
	// container.appendChild( stats.domElement );
	
	// LIGHT
   var light = new THREE.PointLight(0xffffff);
   light.position.set(0,2000,0);
   scene.add(light);

   var light = new THREE.PointLight(0xffffff);
   light.position.set(1000,-1000,0);
   scene.add(light);


	
	// SKYBOX/FOG
	var newColor = new THREE.Color( );
       	//newColor.setRGB(0.9,0.9,0.9);
        newColor.setRGB(0.3,0.3,0.3);
  
	var skyBoxGeometry = new THREE.CubeGeometry( 15000, 15000, 15000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: newColor, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
    skyBox.flipSided = true; // render faces from inside of the cube, instead of from outside (default).
	scene.add(skyBox);
	

	// Mouse
	
	var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: 0.9 } );
	 
	var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
	var pointer = new THREE.Mesh( mouseGeo, pointerMaterial );

	pointer.name = "pointer";
	pointer.position.x = 10;
	pointer.position.y = 10;
	pointer.position.z = 10;
	pointer.updateMatrix();
	pointer.matrixAutoUpdate = false;
	scene.add( pointer );


  
	///////////////////
	// CUSTOM  SHADER//
	///////////////////

	var shaderMaterial;
	var particleSystem;

	//var cubeGeometry = new THREE.CubeGeometry( 50, 50, 50, 20, 20, 20 );
	//var discTexture = THREE.ImageUtils.loadTexture( 'disc.png' );

	// values that are constant for all particles during a draw call
	this.customUniforms = 
	{
		time:	 { type: "f", value: 1.0 }
		
	};

	// properties that may vary from particle to particle. only accessible in vertex shaders!
	//	(can pass color info to fragment shader via vColor.)
	
	this.customAttributes = 
	{
		customColor:	 { type: "c", value: [] },
		customFrequency: { type: 'f', value: [] },
		customSize: { type: 'f', value: [] }
	};
		
 	createSphere(); 
 	  
  	loadSTL();
  
  	// loadTXT();


	// $.ajax({
 //            url : "data/livingRoom2.txt",
 //            dataType: "text",
 //            success : function (data) {
 //            	logText = data;
 //            	//startWebworker();
 //            	loadTXT();
 //            }
 //    });


}


function loadSTL(file){
	var loader = new THREE.STLLoader();

				loader.addEventListener( 'load', function ( event ) {
					
					particleGeo = event.content;

					particlesCount = particleGeo.vertices.length;

					for (var i =  0; i < particlesCount ; i++) {
						

						var pos = new THREE.Vector3(particleGeo.vertices[i].x,particleGeo.vertices[i].y,particleGeo.vertices[i].z);


						var subVector = new THREE.Vector3(0,0,0);
						subVector = pos.sub(new THREE.Vector3(0,0,0));

						var distance = subVector.length();


						var colorMapR = map(distance, 0, 300, .6, 0);
						var colorMapG = map(distance, 0, 300, 0, .5);
						var colorMapB = map(distance, 0, 300, .5, .2);


				        var newColor = new THREE.Color( );
				        newColor.setRGB(1,1,1);


						customAttributes.customColor.value[ i ] = newColor;
        				customAttributes.customSize.value[ i ] =  map(distance, 0, 300, 0, 5);
        				customAttributes.customSize.value[ i ] =  10;

					};

					customAttributes.customColor.needsUpdate = true;
	 				customAttributes.customSize.needsUpdate = true;

					
					addToScene();
				} );


				loader.load( 'data/' + stlName + '' );
				//loader.load(file);
				//loader.load( 'data/room.stl' );

}


function loadTXT(){

	var regFileComplete = /(A|O)/g;

	var counter = 0;

	//vertexCounter = 0;

	// Search for beginning and end in file
	while ((match = regFileComplete.exec(logText)) != null) {
		counter ++;
	}

	if(counter == 2){

		console.log("correct file detected");

		var data = logText.substr(1,logText.length-2);

		//console.log("data: " + data);
		


	//Parser - Get Points

		var regPP = /(P)/g;
		var ppArray = [2];

		var pointsIndex = [];
		var pointCounter = 0; 

		finalPoints = [];


		while ((match = regPP.exec(data)) != null) {

			pointsIndex.push(match.index);
			
			}

			for (var i = 0; i < pointsIndex.length; i++) {
				ppArray[0] = pointsIndex[i];
				ppArray[1] = pointsIndex[i+1];



				if(i % 2 == 0){

					var newPointTXT = new THREE.Vector3(0,0,0);

					var pointValid = false;

					var point = data.substr(ppArray[0]+1,(ppArray[1])-(ppArray[0]+1));

					//Get X Value
						var regXX = /(x)/g;
						var xxArray = [2];
						counter = 0;
						while ((match = regXX.exec(point)) != null) {
							
							if(counter < 3){
								xxArray[counter] =  match.index;
								counter ++;
							}

						}

						var x = point.substr(xxArray[0]+1,xxArray[1]-(xxArray[0]+1));
						
						if( x.length > 0 ){
							//Valid Value
							newPointTXT.x = x;

							pointValid = true;
						} else {
							pointValid = false;
						}


					//Get Y Value
						var regYY = /(y)/g;
						var yyArray = [2];

						counter = 0;

						while ((match = regYY.exec(point)) != null) {
	
							if(counter < 3){
								yyArray[counter] =  match.index;
								counter ++;
							}

						}

						var y = point.substr(yyArray[0]+1,yyArray[1]-(yyArray[0]+1));
						
						if( y.length > 0 ){
							//Valid Value
							newPointTXT.y = y;

							pointValid = true;
						} else {
							pointValid = false;
						}


						


					//Get Z Value

						var regZZ = /(z)/g;
						var zzArray = [2];
						counter = 0;
						while ((match = regZZ.exec(point)) != null) {
							
							if(counter < 3){
								zzArray[counter] =  match.index;
								counter ++;
							}

						}

						var z = point.substr(zzArray[0]+1,zzArray[1]-(zzArray[0]+1));
						
						if( z.length > 0 ){
							//Valid Value
							newPointTXT.z = z;

							pointValid = true;
						} else {
							pointValid = false;
						}


						if(pointValid && (newPointTXT.x + newPointTXT.y) != 0){

							finalPoints.push(newPointTXT);

						}


				}

				
			}
	}


	// Create Point List

	particlesCount = finalPoints.length;

	var color = new THREE.Color();
	
	positions = new Float32Array( particlesCount * 3 );
	colors = new Float32Array( particlesCount * 3);
	sizes = new Float32Array( particlesCount );
	deleteArray = new Int32Array( particlesCount );
	
	vertexCounter = -1;


     for ( var i = 0; i < particlesCount * 3; i += 3 ) {
       
       vertexCounter ++;

		// Point on XZ Plane
		var x = finalPoints[vertexCounter].x * Math.cos(finalPoints[vertexCounter].y*(Math.PI/180));
		var y = 0;
		var z = finalPoints[vertexCounter].x * Math.sin(finalPoints[vertexCounter].y*(Math.PI/180));

		

		// Eliminate zero dots
		if(y + x + z == 0){ 
	    	continue;
		}

		var angle = (map(finalPoints[vertexCounter].z, 175, 805, -5, 175))*(Math.PI/180);
	

		//Translate Point
		 x -=  3 * Math.cos(angle) * (finalPoints[vertexCounter].x * .003); 
		 y -=  3 * Math.sin(angle) * (finalPoints[vertexCounter].x * .003);
		 z -= 0;
		
		// Rotate Point around Z Axis
		x1 = x * Math.cos(angle) - y * Math.sin(angle);
		y1 = x * Math.sin(angle) + y * Math.cos(angle);
		z1 = z;
		
		var distance = finalPoints[vertexCounter].x;
		
		var colorMapR = map(distance, 0, 3000, .6, 0);
		var colorMapG = map(distance, 0, 3000, 0, .5);
		var colorMapB = map(distance, 0, 3000, .5, .2);


        var newColor = new THREE.Color( );
        newColor.setRGB(1,1,1);

       	// Eliminate zero dots
		if(y1 + x1 + z1 == 0){ 
	    	continue;
		}
        
    positions[ i ]     = y1 * -.1;
	positions[ i + 1 ] = (x1 * -.1) - 10;
	positions[ i + 2 ] = z1 * .1;
		
	colors[ i ]     = newColor.r;
	colors[ i + 1 ] = newColor.g;
	colors[ i + 2 ] = newColor.b;
		
	sizes[ vertexCounter] =  map(finalPoints[vertexCounter].x, 0, 3000, 0, 10);

	

	}
		  
		

	//	console.log(positions.length)
		createMesh();

}

function createSphere(){

	var pinkMat = new THREE.MeshPhongMaterial({
		  color      :  new THREE.Color("rgb(100,100,100)"),
		  emissive   :  new THREE.Color("rgb(150,150,150)"),
		  specular   :  new THREE.Color("rgb(155,155,155)"),
		  shininess  :  10,
		  shading    :  THREE.FlatShading,
		  side       : 	THREE.DoubleSide,
		  transparent: 	0,
		  opacity    : 	1,
		  wireframe	 : 	false
		});

	// var loader = new THREE.STLLoader();
	// loader.addEventListener( 'load', function ( event ) {
		
	// 	var bulbGeo = event.content;



	// 	// var icoMaterial =  new THREE.MeshPhongMaterial( { color:new THREE.Color("rgb(255,255,255)"), shading:  THREE.FlatShading, side: THREE.DoubleSide} );


	// 	bulbGeo.computeCentroids();
	// 	bulbGeo.computeFaceNormals();
	// 	bulbGeo.computeVertexNormals(); 


	// 	Ico = new THREE.Mesh(bulbGeo, pinkMat);
	// 	Ico.dynamic = true;
	// 	Ico.doubleSided = true;

	// 	scene.add(Ico);


	// 	//addToScene();
	// } );
	// loader.load( 'data/ico3.stl' );





	Ico = new THREE.Mesh(new THREE.IcosahedronGeometry(7.5,2), pinkMat);
	Ico.dynamic = true;
	Ico.doubleSided = true;


	var lampGeo = new THREE.Geometry();

	for (var i = 0; i <= Ico.geometry.vertices.length - 1; i++) {

			lampGeo.vertices.push(Ico.geometry.vertices[i]);
			
	}

	for (var i = 0; i <= Ico.geometry.faces.length - 1 ; i++) {

			// var leaveOut = false;

			// for (var j = hole.length - 1; j >= 0; j--) {
			// 	if(hole[j] == i){
			// 		leaveOut = true;
			// 	}

			// };

			// // if( i < 40){
			// // 	leaveOut = true;
			// // }
			// if(!leaveOut){
				lampGeo.faces.push(Ico.geometry.faces[i]);
			// }
			
			
	}

		lampGeo.computeCentroids();
		lampGeo.computeFaceNormals();
		lampGeo.computeVertexNormals(); 

	Ico = new THREE.Mesh(lampGeo, pinkMat);

	scene.add(Ico);
	



}


function updateSphere(cutMeshData){


		newLampGeo = new THREE.Geometry();

		//console.log(cutMeshData);

		//Draw debug boxes

		// var geometry = new THREE.BoxGeometry( .1, .1, .1 );
		// var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); 
		// var cube = new THREE.Mesh( geometry, material );

		if(cutMeshData[2] != undefined){
			for(var i = 0; i <= cutMeshData[2].length -3; i +=3){

				var cube = new THREE.Mesh( geometry, material );
				cube.position = new THREE.Vector3(cutMeshData[2][i],cutMeshData[2][i+1],cutMeshData[2][i+2]);
					scene.add( cube );

			}

		}


		for (var i = 0; i <= cutMeshData[0].length - 3 ; i+=3) {

			newLampGeo.vertices.push(new THREE.Vector3(cutMeshData[0][i],cutMeshData[0][i+1],cutMeshData[0][i+2]));
			
		}


		//	var scaleFactor = 7.5;
		var scaleFactor = 10;
		
		var exportGeo = new THREE.Geometry();

		for (var i = 0; i <= cutMeshData[0].length - 3 ; i+=3) {

			exportGeo.vertices.push(new THREE.Vector3(cutMeshData[0][i]*scaleFactor,cutMeshData[0][i+1]*scaleFactor,cutMeshData[0][i+2]*scaleFactor));
			
		}

		for (var i = 0; i <= cutMeshData[1].length - 3 ; i+=3) {
			newLampGeo.faces.push(new THREE.Face3(cutMeshData[1][i],cutMeshData[1][i+1],cutMeshData[1][i+2]));
		}

		for (var i = 0; i <= cutMeshData[1].length - 3 ; i+=3) {
			exportGeo.faces.push(new THREE.Face3(cutMeshData[1][i],cutMeshData[1][i+1],cutMeshData[1][i+2]));
		}


		newLampGeo.computeCentroids();
		newLampGeo.computeFaceNormals();
		newLampGeo.computeVertexNormals(); 

		exportGeo.computeCentroids();
		exportGeo.computeFaceNormals();
		exportGeo.computeVertexNormals(); 


		//Export STL
		var stl = stlFromGeometry( exportGeo, {download:false});

		var blob = new Blob([stl], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "sphere.stl");
		
		var pinkMat = new THREE.MeshPhongMaterial({
		  color      :  new THREE.Color("rgb(100,100,100)"),
		  emissive   :  new THREE.Color("rgb(150,150,150)"),
		  specular   :  new THREE.Color("rgb(155,155,155)"),
		  shininess  :  10,
		  shading    :  THREE.FlatShading,
		  side       : 	THREE.DoubleSide,
		  transparent: 	0,
		  opacity    : 	1,
		  wireframe	 : 	false
		});

		var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );

		newLampMesh = new THREE.Mesh(newLampGeo, pinkMat);


		newLampMesh.name = "newLampMesh";
		scene.add(newLampMesh);

		scene.remove(Ico);


}

function createMesh(){

	particleGeo = new THREE.Geometry();

	// Create Mesh
	vertexCounterSize = 0;
	vertexCounter = 0;
	skipCounter = 0;
	deleteCounter = 0;
	
     // for(var i = 0; i < 1000; i+=3){  
	for(var i = 0; i < positions.length; i+=3){  


		var newPoint = new THREE.Vector3( positions[ i ],	positions[ i + 1 ] , positions[ i + 2 ]);  
		 
		
		if(deleteArray[deleteCounter] == 1){
		   deleteCounter ++;
		   skipCounter ++;
		   vertexCounterSize++;
		   continue;
		   //console.log("skip");
		}else{
			//console.log("not so skip");
		}

		if(newPoint.x + newPoint.y + newPoint.z == 0){
		   deleteCounter ++;
		   skipCounter ++;
		   vertexCounterSize++;
		   continue;
		} 

		if(vertexCounter % 3 == 0 || vertexCounter == 0){
			if(vertexCounter-1 != -1){
				 particleGeo.faces.push( new THREE.Face3(vertexCounter, vertexCounter+1, vertexCounter-1));
			}else{
				particleGeo.faces.push( new THREE.Face3(vertexCounter, vertexCounter+1, vertexCounter+2));
			}
			   
		}

		deleteCounter ++;
		vertexCounter ++;
		vertexCounterSize++;
		        
		particleGeo.vertices.push(
		   newPoint                
		);


		var newColor = new THREE.Color();
		newColor.setRGB(	colors[ i ], 	colors[ i + 1 ], 	colors[ i + 2 ] );
		customAttributes.customColor.value[ vertexCounter-1] = newColor;
		customAttributes.customSize.value[ vertexCounter-1] =  sizes[vertexCounterSize-1];;


	}

       customAttributes.customColor.needsUpdate = true;
	   customAttributes.customSize.needsUpdate = true;
      
	//   console.log("skipped: " + skipCounter);

       addToScene();

}

function addToScene(){


		if(scene.getObjectByName("particleSystem") != undefined){
			scene.remove(particleSystem);
		}

		this.shaderMaterial = new THREE.ShaderMaterial( 
		{
			uniforms: 		customUniforms,
			attributes:		customAttributes,
			vertexShader:   document.getElementById( 'vertexshader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
			transparent: true,
			alphaTest: 0.5
		});
			

			
		this.particleSystem = new THREE.ParticleSystem( particleGeo, this.shaderMaterial );
		this.particleSystem.position.set(0, 0, 0);
		this.particleSystem.dynamic = true;
		this.particleSystem.frustrumCulled = true;
		this.particleSystem.sortParticles = false;
		this.particleSystem.name = "particleSystem";
		scene.add( this.particleSystem );	

		sceneBuilt = true;


}

function switchModel(){
	
	stlNameCounter ++;

	if(stlNameCounter >= stlNames.length){
		stlNameCounter = 0;
	}
	stlName = stlNames[stlNameCounter];
	
	loadSTL();
}

function onMouseMove(event){
  
	mouseCoord = new THREE.Vector3( (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5 );
 	
 	calcPointer();

 	

}

// function onMouseDown(event e){
// 	mouseHold = true;
// 	mouseOpacity = 0;
// 	mouseCounter = 0;
// 	updatePointerColor(mouseOpacity);

// 	switch (e.which) {
//         case 1:
//             alert('Left Mouse button pressed.');
//             break;
//         case 2:
//             alert('Middle Mouse button pressed.');
//             break;
//         case 3:
//             alert('Right Mouse button pressed.');
//             break;
//         default:
//             alert('You have a strange Mouse!');
//     }
// }

function onKeyDown(event) {


		// Space Bar
			if(event.charCode == 32){
				markPoints();
			}

				

    
};

function markPoints(){
	//selectedMesh = new THREE.Geometry();

				for ( var i = 0; i < particleGeo.vertices.length; i ++ ) {
              
		            var vertex = particleGeo.vertices[i];
		             
		              //Get the current camera position  
		            new_pos.copy(camera.position);
		             
		             //Get the smallest distance to the cube and if the distance is smaller than
		             // the distance from camera to cube divided by ten (imaginary contact with sphere),
		             // change the color
		            if(raycaster.ray.distanceToPoint(vertex) <= new_pos.sub(vertex).length()/20 ){
		                  
		                  

		                var newColor = new THREE.Color( );
       					
       					newColor.setRGB(.9,.8,.2);

		                
		                customAttributes.customColor.value[ i ] = newColor;
		                customAttributes.customSize.value[ i ] = 25;
		                  
		                  

   		                selectedMesh.vertices.push(vertex);
		                  
		                  


			            var material = new THREE.LineBasicMaterial({color: newColor, opacity: .5 });

			            material.transparent = true;

						var geometry = new THREE.Geometry();
						geometry.vertices.push(
							new THREE.Vector3( 0, 0, 0 ),
							vertex
						);

						var line = new THREE.Line( geometry, material );
					//	scene.add( line );

		                  
						customAttributes.customColor.needsUpdate = true;
						customAttributes.customSize.needsUpdate = true;

	              	}
	              
	            }
	        
}

function postToCutOutWorker(){
	 // Convert Mesh data into ArrayBuffer for Webworker

	        	var selecteMeshBuffer = new Float32Array( selectedMesh.vertices.length * 3);
	          	var icoVertices = new Float32Array((Ico.geometry.vertices.length - 0) * 3);
	          	var icoFacesCentroids = new Float32Array((Ico.geometry.faces.length -0) * 3);
	          	var icoFaces = new Float32Array((Ico.geometry.faces.length -0) * 3);


	        	var vertexCounter = 0;
		        for (var i = 0; i <= selecteMeshBuffer.length - 3; i+=3) {
		        	selecteMeshBuffer[i] =   selectedMesh.vertices[vertexCounter].x;
		          	selecteMeshBuffer[i+1] = selectedMesh.vertices[vertexCounter].y;
		          	selecteMeshBuffer[i+2] = selectedMesh.vertices[vertexCounter].z;
		          	vertexCounter++;
		        };

	          	var vertexCounter = 0;
		        for (var i = 0; i <= icoVertices.length - 3; i+=3) {
					icoVertices[i] =   Ico.geometry.vertices[vertexCounter].x;
	         	 	icoVertices[i+1] = Ico.geometry.vertices[vertexCounter].y;
	          		icoVertices[i+2] = Ico.geometry.vertices[vertexCounter].z;

		          	vertexCounter++;   	
		        };

		        var vertexCounter = 0;
		        for (var i = 0; i <= icoFaces.length - 3; i+=3) {
		        	// if(vertexCounter == 0){
		        	// 	icoFacesCentroids[i] =   0;
		         //  		icoFacesCentroids[i+1] = 0;
		         //  		icoFacesCentroids[i+2] = 0;
		        	// }else{


		          	icoFacesCentroids[i] =   Ico.geometry.faces[vertexCounter].centroid.x;
		          	icoFacesCentroids[i+1] = Ico.geometry.faces[vertexCounter].centroid.y;
		          	icoFacesCentroids[i+2] = Ico.geometry.faces[vertexCounter].centroid.z;
		          	// }
		          	vertexCounter++;
		        };

				var vertexCounter = 0;
		        for (var i = 0; i <= icoFaces.length - 3; i+=3) {
		        	// if(vertexCounter == 0){
		        	// 	icoFaces[i] =   0;
		         //  		icoFaces[i+1] = 0;
		         //  		icoFaces[i+2] = 0;
		        	// } else {


		          	icoFaces[i] =   Ico.geometry.faces[vertexCounter].a;
		          	icoFaces[i+1] = Ico.geometry.faces[vertexCounter].b;
		          	icoFaces[i+2] = Ico.geometry.faces[vertexCounter].c;
		         	// }
		          	vertexCounter++;
		        };



        		var buffers = [ selecteMeshBuffer, icoVertices, icoFacesCentroids, icoFaces, extrude, thickness, recursions, tipThickness, holeFactor];

        		//console.log(buffers);
        		//console.log(selecteMeshBuffer);
         		cutoutWorker.postMessage(buffers);
}

function calcPointer(){

	// Create Camera Vector
  cameraVector.applyQuaternion( camera.quaternion );
   
	mouseX = mouseCoord.x;

	//New Projector Class picking ray
   raycaster = projector.pickingRay(mouseCoord, camera);

   var pos = raycaster.ray.intersectPlane(planeZ);


     // Position object near camera - move it along vector between camera and calculated
     // pos
		
		 if(pos != null){
			 new_pos2.copy(pos);  
			}


     new_pos2.sub(camera.position);


     new_pos2.normalize();
     new_pos2.multiplyScalar(20);

     new_pos2.add(camera.position);

     object = scene.getObjectByName( "pointer" );


     object.position.set(new_pos2.x,new_pos2.y,new_pos2.z);
     object.updateMatrix();
}

function exportGeometry(){
	var stl = stlFromGeometry( particleGeo, {download:false});

	var blob = new Blob([stl], {type: "text/plain;charset=utf-8"});
	saveAs(blob, "room.stl");
}

function updatePointerColor(opacity){
	//console.log("update color");
	var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: opacity } );

	scene.getObjectByName( "pointer" ).material = pointerMaterial;
	scene.getObjectByName( "pointer" ).material.needsUpdate = true;
}

function checkCamera(){
 if(camera.quaternion.x == cameraOld){
    //console.log("change");
   // mouseHold = true;
  // scene.getObjectByName( "pointer" ).visible = true;
    //calcPointer();
  } else {
     mouseHold = true;
	 mouseOpacity = 0;
	 mouseCounter = 0;
	 updatePointerColor(mouseOpacity);
     
 }
  
 cameraOld = camera.quaternion.x;
}

function animate(){



 requestAnimationFrame( animate );

 if(infoActiveCounter > 10){
	return;
}


	render();		
	update();

if(infoActive && sceneBuilt){
	infoActiveCounter ++;
}

}

function update(){


//console.log(mouseOpacity);
	
	if(mouseOpacity >= 1){
		mouseHold = false;
	}

	if ( mouseHold) 
	{ 	
		if(mouseCounter <= 1){
			mouseCounter += .01;
		}
		
		if(mouseCounter > .5){
			mouseOpacity += .1;

			updatePointerColor(mouseOpacity);
		}
		
	}

	if(doMark){
		markPoints();
	}
	

	

	controls.update();
	//stats.update();
    //checkCamera();
	//var t = clock.getElapsedTime();
	//customUniforms.time.value = 0.1;
}

function render() 
{

	renderer.render( scene, camera );
}
function onWindowResize() {

	if(!infoActive){
		
		$("#info").removeClass("transitionLeft");
		$("#info").css("left",""+  -$("#info_ghost").width()*2 -$("#info_ghost").offset().left*2-60 +"px");

	}
	
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );


}
</script>

</body>
</html>