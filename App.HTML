<!doctype html>
<html lang="en">
<head>
	<title>ParticleSystem - Dynamic (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body style="overflow:hidden">


<script src="js/Three.js"></script>

<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="threeoctree.min.js"></script>




<!-- Custom shaders for particle effects -->
<script type="x-shader/x-vertex" id="vertexshader">
uniform float time;
attribute float customFrequency;
attribute float customSize;
attribute vec3 customColor;
varying vec3 vColor;






void main() 
{
	vColor = customColor; // set color associated to vertex; use later in fragment shader
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = sin(time) * customSize * 8.0 * ( 10.0 / length( mvPosition.xyz ) );
	gl_Position = projectionMatrix * mvPosition;
}



</script>



<script type="x-shader/x-fragment" id="fragmentshader">
uniform sampler2D texture;
varying vec3 vColor; // colors associated to vertices; assigned by vertex shader
void main() 
{
	// calculates a color for the particle
	gl_FragColor = vec4( vColor, 1.0 );
	// sets particle texture to desired color
	gl_FragColor = gl_FragColor;
}
</script>
<!-- end of custom shaders -->




<!-- jQuery code to display an information button and box when clicked. -->
<script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<script src="js/info.js"></script>



<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
*/

// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
var cameraOld;

// global variables
var cube;
var zeroCounter = 0;
var particleGeo = new THREE.Geometry();
var vertexCounter = 0;
var vertexCounter1 = 0;
var mouseCoord = new THREE.Vector3(0,0,0);
var mouseOpacity;

var positions;
var colors;
var sizes;

var createMeshFlag = false;

var createCounterOld = 0;
var createCounter = 0;

init();
animate();

var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
direction = new THREE.Vector3( 1, 0, 0 );


var cameraVector = new THREE.Vector3( 0, 0, -1 );
var new_pos = new THREE.Vector3( 0, 0, 0 );
var new_pos2 = new THREE.Vector3( 0, 0, 0 );
var raycaster;
var planeZ = new THREE.Plane(cameraVector, 0);

var octree;
var octreeMesh;

var octreeMaterial;

// FUNCTIONS
 	
function map(x,a,b,c,d){
		return (x-a)/(b-a) * (d-c) + c;
}
	
	
Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};

 
 
	
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	
	projector = new THREE.Projector();
	
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.z = 100;
	camera.lookAt(scene.position);	
	
	// RENDERER
//	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	//else
	//renderer = new THREE.CanvasRenderer(); 
	renderer.setSize( window.innerWidth, window.innerHeight );
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	$( document ).ready(function(){
    $(window).keypress(onKeyDown);
    $(window).mousemove(onMouseMove);
    $(window).mousedown(onMouseMove);    
  });
	window.addEventListener( 'resize', onWindowResize, false );

	
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	
	// LIGHT
  // var light = new THREE.PointLight(0xffffff);
  // light.position.set(0,250,0);
  // scene.add(light);
	
	// SKYBOX/FOG
	var newColor = new THREE.Color( );
  newColor.setRGB(0.9,0.9,0.9);
  
	var skyBoxGeometry = new THREE.CubeGeometry( 15000, 15000, 15000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: newColor, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
  skyBox.flipSided = true; // render faces from inside of the cube, instead of from outside (default).
	scene.add(skyBox);
	
	// Mouse
	
	var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: 0.9 } );
 
	var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
  var pointer = new THREE.Mesh( mouseGeo, pointerMaterial );

  pointer.name = "pointer";
  pointer.position.x = 10;
  pointer.position.y = 10;
  pointer.position.z = 10;
  pointer.updateMatrix();
  pointer.matrixAutoUpdate = false;
  scene.add( pointer );
  
  
  
  octree = new THREE.Octree( {
		// uncomment below to see the octree (may kill the fps)
		//scene: scene,
		// when undeferred = true, objects are inserted immediately
		// instead of being deferred until next octree.update() call
		// this may decrease performance as it forces a matrix update
		undeferred: false,
		// set the max depth of tree
		depthMax: Infinity,
		// max number of objects before nodes split or merge
		objectsThreshold: 8,
		// percent between 0 and 1 that nodes will overlap each other
		// helps insert objects that lie over more than one node
		overlapPct: 0.15
	} );
	

  octreeMaterial = new THREE.MeshBasicMaterial();
	
	
	
	////////////
	// CUSTOM //
	////////////
	
	var shaderMaterial;
	var particleSystem;
	
	var cubeGeometry = new THREE.CubeGeometry( 50, 50, 50, 20, 20, 20 );
	var discTexture = THREE.ImageUtils.loadTexture( 'disc.png' );
	
	// values that are constant for all particles during a draw call
	this.customUniforms = 
	{
		time:	 { type: "f", value: 1.0 },
		texture: { type: "t", value: discTexture },
	};
	
	// properties that may vary from particle to particle. only accessible in vertex shaders!
	//	(can pass color info to fragment shader via vColor.)
	this.customAttributes = 
	{
		customColor:	 { type: "c", value: [] },
		customFrequency: { type: 'f', value: [] },
		customSize: { type: 'f', value: [] }
	};
	
	

   
   $.getJSON( "LOGFILE.json", function( data ) {
       pointData = data;
       check();
       
   });   

          
   function check() {
     
        particlesCount = Math.floor(Object.size(pointData.points) / 3);

				var color = new THREE.Color();
				
				positions = new Float32Array( particlesCount * 3 );
				colors = new Float32Array( particlesCount * 3);
				sizes = new Float32Array( particlesCount );
	
     for ( var i = 0; i < particlesCount * 3; i += 3 ) {
       
      	if(pointData.points[i] == undefined && i <=  particlesCount * 3){
					console.log("something is wrong in the data at: " + i);
					continue;
       }

				// Point on XZ Plane
				var x = pointData.points[i].x * Math.cos(pointData.points[i].y*(Math.PI/180));
				var y = 0;
				var z = pointData.points[i].x * Math.sin(pointData.points[i].y*(Math.PI/180));

        vertexCounter ++;
        
				// Eliminate zero dots
				if(y + x + z == 0){ 
			    continue;
				}
				
			
				
				var angle = (map(pointData.points[i].z, 212, 812, 0, 180))*(Math.PI/180);
				
				//Translate Point
				 x -= 50 * Math.cos(angle);
				 y -= 50 * Math.sin(angle);
				 z -= 0;
				
				// Rotate Point around Z Axis
				x1 = x * Math.cos(angle) - y * Math.sin(angle);
				y1 = x * Math.sin(angle) + y * Math.cos(angle);
				z1 = z;
				

				var colorMapR = map(pointData.points[i].x, 0, 8000, .5, 0);
				var colorMapG = map(pointData.points[i].x, 0, 3000, 0, .5);
				var colorMapB = map(pointData.points[i].x, 0, 5000, .5, .2);


        var newColor = new THREE.Color( );
        newColor.setRGB(0.2,0.2,colorMapB);
       // vertexCounter ++;
        
        positions[ i ]     = y1 * .1;
				positions[ i + 1 ] = x1 * .1;
				positions[ i + 2 ] = z1 * .1;
				
				colors[ i ]     = newColor.r;
				colors[ i + 1 ] = newColor.g;
				colors[ i + 2 ] = newColor.b;
				
				sizes[ vertexCounter -1] =  map(pointData.points[i].x, 0, 5000, 0, 100);

			}
		  
		  createMeshFlag = true;
       
		}

}



function createMesh(){
  
  // Create Mesh
  var vertexCounterSize = 0;
  var skipCounter = 0;
  
  vertexCounter = 0;
  
  loop1:
  //for(var i = 0; i < 5000; i+=3){  
//  for(var i = 0; i < positions.length; i+=3){
  for(var i = 0; i < 5000; i+=3){	
  
            
   // if(createCounter <= positions.length){
   
        var newPoint = new THREE.Vector3( positions[ i ],	positions[ i + 1 ] , positions[ i + 2 ])  
     
        var minDistance = 1000000;
    
        // Threading simulation needed  
        // for(var j = 0; j < 5000; j+=3){  
        //   
        //   var otherPoint = new THREE.Vector3( positions[ j ],  positions[ j + 1 ] , positions[ j + 2 ]);
        //   var distance = new THREE.Vector3();
        //   
        //   distance.subVectors(newPoint,otherPoint);
        //   var length = distance.length();
        //   if(length < minDistance && length != 0){
        //     minDistance = length;
        //     //console.log(distance.length());
        //   }
        //   
        // }
        // 
        // 
        // //if(minDistance >= 5 + sizes[vertexCounterSize-1]){
        // if(minDistance >= 5){
        //   
        //   skipCounter ++;
        //   vertexCounterSize++;
        //   continue;
        //   
        // }
    
    
    
    
        //console.log(skipCounter);

    
        // Distance Threshold
        // if(pointData.points[i].x >= 5000){
        //   vertexCounterSize++;
        //     continue;
        // }
    
        vertexCounter ++;
        vertexCounterSize++;
            
        particleGeo.vertices.push(
           newPoint                
        );
    
        var newColor = new THREE.Color();
        newColor.setRGB(	colors[ i ], 	colors[ i + 1 ], 	colors[ i + 2 ] );
        customAttributes.customColor.value[ vertexCounter-1] = newColor;
        customAttributes.customSize.value[ vertexCounter-1] =  sizes[vertexCounterSize-1];       
   
    // }
     
  }
  
  //console.log(skipCounter);
  
	       

	       octreeMesh = new THREE.Mesh( particleGeo, octreeMaterial );

	       octree.add( octreeMesh, { useVertices: true } );

	       octree.update();

	       //console.log(octree);
			
		   createMeshFlag = false;

}

function createParticleSystem(){
  
  
  this.shaderMaterial = new THREE.ShaderMaterial( 
	{
		uniforms: 		customUniforms,
		attributes:		customAttributes,
		vertexShader:   document.getElementById( 'vertexshader' ).textContent,
		fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
		transparent: true, alphaTest: 0.5,  // if having transparency issues, try including: alphaTest: 0.5, 
		// blending: THREE.AdditiveBlending, depthTest: false,
	});
	
	
	
	
  this.particleSystem = new THREE.ParticleSystem( particleGeo, this.shaderMaterial );
	this.particleSystem.position.set(0, 0, 0);
	this.particleSystem.dynamic = true;
	this.particleSystem.frustrumCulled = true;
	this.particleSystem.sortParticles = false;
	scene.add( this.particleSystem );
}

function onMouseMove(event){
  
  mouseCoord = new THREE.Vector3(
      (event.clientX / window.innerWidth) * 2 - 1,
      -(event.clientY / window.innerHeight) * 2 + 1,
      0.5 );
      
  calcPointer();

};

function onKeyDown(event) {


var octreeObjects;
var numObjects;
var numFaces = 0;
var intersections;
var vector = new THREE.Vector3( mouseCoord.x, mouseCoord.y, 0.5 );
// var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

var projector = new THREE.Projector();
    projector.unprojectVector( mouseCoord, camera );

var origin = new THREE.Vector3().copy( camera.position );
var direction = new THREE.Vector3().copy( mouseCoord.sub( camera.position ) ).normalize();
var rayCaster = new THREE.Raycaster( origin, direction );
 

  octreeObjects = octree.search( raycaster.ray.origin, raycaster.ray.far, true, raycaster.ray.direction );
				
	intersections = raycaster.intersectOctreeObjects( octreeObjects );
	
	numObjects = octreeObjects.length;
	
	for ( var i = 0, il = numObjects; i < il; i++ ) {
		
		numFaces += octreeObjects[ i ].vertices.length;
		
	}

	console.log(numFaces);


// ---------------------- OLD ------------------
//              for ( var i = 0; i < vertexCounter; i ++ ) {
              
//              var vertex = particleGeo.vertices[i];     
             
//               //Get the current camera position  
//              new_pos.copy(camera.position);
             
//              //Get the smallest distance to the cube and if the distance is smaller than
//              // the distance from camera to cube divided by ten (imaginary contact with sphere),
//              // change the color
//              if(raycaster.ray.distanceToPoint(vertex) <= new_pos.sub(vertex).length()/20 ){
                  
//                  // console.log(i);
                  
//                   var newColor = new THREE.Color( 0xffffff );
//                   customAttributes.customColor.value[ i ] = newColor;
//                   customAttributes.customSize.value[ i ] = 20;
                  
                  
//                   console.log(i);
                  
// 								  customAttributes.customColor.needsUpdate = true;
// 								  customAttributes.customSize.needsUpdate = true;
//               }
              
//              } 
};

function calcPointer(){

	// Create Camera Vector
  cameraVector.applyQuaternion( camera.quaternion );
   
	mouseX = mouseCoord.x;
	//console.log(event.clientX)
	// Mouse Position on Screen (Worldpos?)
   // var mv = new THREE.Vector3(
   //     (event.clientX / window.innerWidth) * 2 - 1,
   //     -(event.clientY / window.innerHeight) * 2 + 1,
   //     0.5 );
     
	//New Projector Class picking ray
   raycaster = projector.pickingRay(mouseCoord, camera);

   var pos = raycaster.ray.intersectPlane(planeZ);


     // Position object near camera - move it along vector between camera and calculated
     // pos
		
		 if(pos != null){
			 new_pos2.copy(pos);  
			}


     new_pos2.sub(camera.position);


     new_pos2.normalize();
     new_pos2.multiplyScalar(20);

     new_pos2.add(camera.position);

     object = scene.getObjectByName( "pointer" );


     object.position.set(new_pos2.x,new_pos2.y,new_pos2.z);
     object.updateMatrix();
     
}

function checkCamera(){
  if(camera.quaternion.x == cameraOld){
    //console.log("change");
     scene.getObjectByName( "pointer" ).visible = true;
 //  calcPointer();
  } else {
     scene.getObjectByName( "pointer" ).visible = false;
     
  }
  
  cameraOld = camera.quaternion.x;
}

function animate() 
{
  requestAnimationFrame( animate );
	render();		
	update();
	
}

function update()
{
	if ( keyboard.pressed("z") ) 
	{ 
		// do something
	}
	controls.update();
	stats.update();
 	checkCamera();

  
  if(createMeshFlag){
    createMesh();
    createParticleSystem();
  }
   

	//var t = clock.getElapsedTime();
	//customUniforms.time.value = 0.1;
}

function render() 
{
	renderer.render( scene, camera );
}

function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );


}
</script>

</body>
</html>