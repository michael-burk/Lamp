<!doctype html>
<html lang="en">
<head>
	<title>ParticleSystem - Dynamic (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body style="overflow:hidden">


<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/jquery-2.1.1.min.js"></script>
<script src="js/cleanMesh.js"></script>
<script src="js/cutout.js"></script>

<!--Copyright (C) 2012 Philipp Sackl, envis precisely GmbH-->
<script type="text/javascript" charset="utf-8" src="js/THREE2STL.js"></script>

<script type="text/javascript" src="js/BinaryLoader.js"></script>
<script type="text/javascript" src="js/STLLoader.js"></script>

<script type="text/javascript" src="js/BoxGeometry.js"></script>



<div style="width: 300px; height: 300px; z-index: 100;"id="drop_zone">Drop files here</div>
<output id="list"></output>


<!-- Custom shaders for particle effects -->
<script type="x-shader/x-vertex" id="vertexshader">
uniform float time;
attribute float customFrequency;
attribute float customSize;
attribute vec3 customColor;
varying vec3 vColor;
void main() 
{
	vColor = customColor; // set color associated to vertex; use later in fragment shader
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = sin(time) * customSize * 8.0 * ( 10.0 / length( mvPosition.xyz ) );
	gl_Position = projectionMatrix * mvPosition;
}
</script>



<script type="x-shader/x-fragment" id="fragmentshader">
uniform sampler2D texture;
varying vec3 vColor; // colors associated to vertices; assigned by vertex shader
void main() 
{
	// calculates a color for the particle
	gl_FragColor = vec4( vColor, 1.0 );
	// sets particle texture to desired color
	gl_FragColor = gl_FragColor;
}
</script>
<!-- end of custom shaders -->


<!-- jQuery code to display an information button and box when clicked. -->
<script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<script src="js/info.js"></script>



<div id="ThreeJS" style="position: absolute; left:0px; top:0px; z-index: -1;"></div>


<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
*/

// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
var cameraOld;

// global variables
var cube;
var zeroCounter = 0;
var particleGeo = new THREE.Geometry();
var vertexCounter = 0;
var vertexCounter1 = 0;
var vertexCounterSize = 0;
var deleteCounter = 0;
var mouseCoord = new THREE.Vector3(0,0,0);
var mouseOpacity;

var positions;
var colors;
var sizes;
var deleteArray;

var skipCounter;

init();
animate();

var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
direction = new THREE.Vector3( 1, 0, 0 );



var cameraVector = new THREE.Vector3( 0, 0, -1 );
var new_pos = new THREE.Vector3( 0, 0, 0 );
var new_pos2 = new THREE.Vector3( 0, 0, 0 );
var raycaster;
var planeZ = new THREE.Plane(cameraVector, 0);

var logText;

//var Ico;
var selectedMesh = new THREE.Geometry();
var toDelete = [];

// FUNCTIONS
 	
function map(x,a,b,c,d){
		return (x-a)/(b-a) * (d-c) + c;
}
	
	
Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};


// Declare webworker

var worker = new Worker('js/cleanMesh.js');

worker.addEventListener('message', function(e) {

	deleteArray = e.data;

	scene.remove(particleSystem);
	particleGeo = new THREE.Geometry();
	createMesh();
	stlFromGeometry( particleGeo, {download:true});
	console.log('Worker said: ', e.data);
	

}, false);


var cutoutWorker = new Worker('js/cutout.js');

cutoutWorker.addEventListener('message', function(e) {

	updateSphere(e.data);
	//console.log('Worker said: ', e.data);
	console.log(e.data.length);
	

}, false);

 


	
function init(){

	var reader = new FileReader();

	

	function handleFileSelect(evt) {
    evt.stopPropagation();
    evt.preventDefault();

    var files = evt.dataTransfer.files; // FileList object.
    

    // files is a FileList of File objects. List some properties.
    var output = [];

    reader.onload = function(e) {
  		logText = reader.result;
  		//console.log(logText);

	}

	// for (var i = 0, f; f = files[i]; i++) {
 //      output.push('<li><strong>', escape(f.name), '</strong> (', f.type || 'n/a', ') - ',
 //                  f.size, ' bytes, last modified: ',
 //                  f.lastModifiedDate ? f.lastModifiedDate.toLocaleDateString() : 'n/a',
 //                  '</li>');
      
 //    }
    reader.readAsText(files[0]);
  //  document.getElementById('list').innerHTML = '<ul>' + output.join('') + '</ul>';

    
  }

  function handleDragOver(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
  }

  // Setup the dnd listeners.
  var dropZone = document.getElementById('drop_zone');
  dropZone.addEventListener('dragover', handleDragOver, false);
  dropZone.addEventListener('drop', handleFileSelect, false);





	// SCENE
	scene = new THREE.Scene();
	
	projector = new THREE.Projector();
	
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.z = 100;
	camera.lookAt(scene.position);	
	
	// RENDERER

	renderer = new THREE.WebGLRenderer( {antialias:true} );

	renderer.setSize( window.innerWidth, window.innerHeight );
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	$( document ).ready(function(){
    	$(window).keypress(onKeyDown);
    	$(window).mousemove(onMouseMove);
    	$(window).mousedown(onMouseMove);    
  	});

	window.addEventListener( 'resize', onWindowResize, false );

	
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	
	// LIGHT
   var light = new THREE.PointLight(0xffffff);
   light.position.set(200,1000,0);
   scene.add(light);

   var light = new THREE.PointLight(0xffffff);
   light.position.set(1000,-1000,0);
   scene.add(light);


	
	// SKYBOX/FOG
	var newColor = new THREE.Color( );
        newColor.setRGB(0.9,0.9,0.9);
  
	var skyBoxGeometry = new THREE.CubeGeometry( 15000, 15000, 15000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: newColor, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
    skyBox.flipSided = true; // render faces from inside of the cube, instead of from outside (default).
	scene.add(skyBox);
	

	// Mouse
	
	var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: 0.9 } );
	 
	var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
	var pointer = new THREE.Mesh( mouseGeo, pointerMaterial );

	pointer.name = "pointer";
	pointer.position.x = 10;
	pointer.position.y = 10;
	pointer.position.z = 10;
	pointer.updateMatrix();
	pointer.matrixAutoUpdate = false;
	scene.add( pointer );


  
	///////////////////
	// CUSTOM  SHADER//
	///////////////////

	var shaderMaterial;
	var particleSystem;

	//var cubeGeometry = new THREE.CubeGeometry( 50, 50, 50, 20, 20, 20 );
	//var discTexture = THREE.ImageUtils.loadTexture( 'disc.png' );

	// values that are constant for all particles during a draw call
	this.customUniforms = 
	{
		time:	 { type: "f", value: 1.0 }
		
	};

	// properties that may vary from particle to particle. only accessible in vertex shaders!
	//	(can pass color info to fragment shader via vColor.)
	
	this.customAttributes = 
	{
		customColor:	 { type: "c", value: [] },
		customFrequency: { type: 'f', value: [] },
		customSize: { type: 'f', value: [] }
	};
		
		

 	createSphere(); 
 	  
  // $.getJSON( "LOGFILE4.json", function( data ) {
  //   pointData = data;
  //   loadJSON();
  // });


	//loadSTL();
 //    $.get("LOG1.txt", function(respons) {
 //     	logfile = respons;
 //     	alert(respons);
	// });


}


function loadSTL(){
	var loader = new THREE.STLLoader();
				loader.addEventListener( 'load', function ( event ) {
					
					particleGeo = event.content;

					particlesCount = particleGeo.vertices.length;

					for (var i =  0; i < particlesCount ; i++) {
						

						var pos = new THREE.Vector3(particleGeo.vertices[i].x,particleGeo.vertices[i].y,particleGeo.vertices[i].z);


						var subVector = new THREE.Vector3(0,0,0);
						subVector = pos.sub(new THREE.Vector3(0,0,0));

						var distance = subVector.length();


						var colorMapR = map(distance, 0, 8000, .5, 0);
						var colorMapG = map(distance, 0, 3000, 0, .5);
						var colorMapB = map(distance, 0, 500, .5, .2);


				        var newColor = new THREE.Color( );
				        newColor.setRGB(0.2,0.2,colorMapB);


						customAttributes.customColor.value[ i ] = newColor;
        				customAttributes.customSize.value[ i ] =  map(distance, 0, 500, 0, 100);

					};

					customAttributes.customColor.needsUpdate = true;
	 				customAttributes.customSize.needsUpdate = true;

					//createMesh();
					addToScene();
				} );
				loader.load( 'LOGFILE.stl' );

}

function loadJSON() {
     
    particlesCount = Math.floor(Object.size(pointData.points) / 3);

		var color = new THREE.Color();
		
		positions = new Float32Array( particlesCount * 3 );
		colors = new Float32Array( particlesCount * 3);
		sizes = new Float32Array( particlesCount );
		deleteArray = new Int32Array( particlesCount );
	
     for ( var i = 0; i < particlesCount * 3; i += 3 ) {
       
      	if(pointData.points[i] == undefined && i <=  particlesCount * 3){
					console.log("something is wrong in the data at: " + i);
					continue;
       }

		// Point on XZ Plane
		var x = pointData.points[i].x * Math.cos(pointData.points[i].y*(Math.PI/180));
		var y = 0;
		var z = pointData.points[i].x * Math.sin(pointData.points[i].y*(Math.PI/180));

		vertexCounter ++;

		// Eliminate zero dots
		if(y + x + z == 0){ 
	    	continue;
		}

		var angle = (map(pointData.points[i].z, 212, 812, 0, 180))*(Math.PI/180);
		
		//Translate Point
		 x -= 50 * Math.cos(angle);
		 y -= 50 * Math.sin(angle);
		 z -= 0;
		
		// Rotate Point around Z Axis
		x1 = x * Math.cos(angle) - y * Math.sin(angle);
		y1 = x * Math.sin(angle) + y * Math.cos(angle);
		z1 = z;
		

		var colorMapR = map(pointData.points[i].x, 0, 8000, .5, 0);
		var colorMapG = map(pointData.points[i].x, 0, 3000, 0, .5);
		var colorMapB = map(pointData.points[i].x, 0, 5000, .5, .2);


        var newColor = new THREE.Color( );
        newColor.setRGB(0.2,0.2,colorMapB);

       	// Eliminate zero dots
		if(y1 + x1 + z1 == 0){ 
	    	continue;
		}
        
        positions[ i ]     = y1 * .1;
		positions[ i + 1 ] = x1 * .1;
		positions[ i + 2 ] = z1 * .1;
		
		colors[ i ]     = newColor.r;
		colors[ i + 1 ] = newColor.g;
		colors[ i + 2 ] = newColor.b;
		
		sizes[ vertexCounter -1] =  map(pointData.points[i].x, 0, 5000, 0, 100);

		}
		  
		  
		worker.postMessage(positions); // Send data to our worker.

		createMesh();
		  
}

function loadTXT(){

	var regFileComplete = /(A|O)/g;

	var counter = 0;

	// Search for beginning and end in file
	while ((match = regFileComplete.exec(logText)) != null) {
		counter ++;
	}

	if(counter == 2){

		console.log("Start and End detected");

		var data = logText.substr(1,logText.length-2);

		console.log("data: " + data);
		


		//Get Points

		var regPP = /(P)/g;
		var ppArray = [2];

		var pointsIndex = [];
		var pointCounter = 0; 

		var finalPoints = [];


		while ((match = regPP.exec(data)) != null) {

			pointsIndex.push(match.index);
			
			}

			for (var i = 0; i < pointsIndex.length; i++) {
				ppArray[0] = pointsIndex[i];
				ppArray[1] = pointsIndex[i+1];



				if(i % 2 == 0){

					var newPointTXT = new THREE.Vector3(0,0,0);

					var pointValid = false;

					var point = data.substr(ppArray[0]+1,(ppArray[1])-(ppArray[0]+1));

					//console.log("point: " + point);




					//Get X Value
						var regXX = /(x)/g;
						var xxArray = [2];
						counter = 0;
						while ((match = regXX.exec(point)) != null) {
							
							if(counter < 3){
								xxArray[counter] =  match.index;
								counter ++;
							}

						}

						var x = point.substr(xxArray[0]+1,xxArray[1]-(xxArray[0]+1));
						
						if( x.length > 0 ){
							//Valid Value
							newPointTXT.x = x;

							pointValid = true;
						} else {
							pointValid = false;
						}


						


					//Get Y Value
						var regYY = /(y)/g;
						var yyArray = [2];

						counter = 0;

						while ((match = regYY.exec(point)) != null) {
	
							if(counter < 3){
								yyArray[counter] =  match.index;
								counter ++;
							}

						}

						var y = point.substr(yyArray[0]+1,yyArray[1]-(yyArray[0]+1));
						
						if( y.length > 0 ){
							//Valid Value
							newPointTXT.y = y;

							pointValid = true;
						} else {
							pointValid = false;
						}


						


					//Get Z Value

						var regZZ = /(z)/g;
						var zzArray = [2];
						counter = 0;
						while ((match = regZZ.exec(point)) != null) {
							
							if(counter < 3){
								zzArray[counter] =  match.index;
								counter ++;
							}

						}

						var z = point.substr(zzArray[0]+1,zzArray[1]-(zzArray[0]+1));
						
						if( z.length > 0 ){
							//Valid Value
							newPointTXT.z = z;

							pointValid = true;
						} else {
							pointValid = false;
						}


						if(pointValid){

							finalPoints.push(newPointTXT);

						}


				}

				
			}
			//console.log(finalPoints);
	}


// Create Point List like in JSON loader

	particlesCount = finalPoints.length;

		var color = new THREE.Color();
		
		positions = new Float32Array( particlesCount * 3 );
		colors = new Float32Array( particlesCount * 3);
		sizes = new Float32Array( particlesCount );
		deleteArray = new Int32Array( particlesCount );
	
	vertexCounter = -1;

     for ( var i = 0; i < particlesCount * 3; i += 3 ) {
       
     //   if(finalPoints[i] == undefined && i <=  particlesCount){
					// console.log("something is wrong in the data at: " + i);
					// continue;
     //   }
       vertexCounter ++;

		// Point on XZ Plane
		var x = finalPoints[vertexCounter].x * Math.cos(finalPoints[vertexCounter].y*(Math.PI/180));
		var y = 0;
		var z = finalPoints[vertexCounter].x * Math.sin(finalPoints[vertexCounter].y*(Math.PI/180));

		

		// Eliminate zero dots
		if(y + x + z == 0){ 
	    	continue;
		}

		var angle = (map(finalPoints[vertexCounter].z, 212, 812, 0, 180))*(Math.PI/180);
		
		//Translate Point
		 x -= 50 * Math.cos(angle);
		 y -= 50 * Math.sin(angle);
		 z -= 0;
		
		// Rotate Point around Z Axis
		x1 = x * Math.cos(angle) - y * Math.sin(angle);
		y1 = x * Math.sin(angle) + y * Math.cos(angle);
		z1 = z;
		

		var colorMapR = map(finalPoints[vertexCounter].x, 0, 8000, .5, 0);
		var colorMapG = map(finalPoints[vertexCounter].x, 0, 3000, 0, .5);
		var colorMapB = map(finalPoints[vertexCounter].x, 0, 5000, .5, .2);


        var newColor = new THREE.Color( );
        newColor.setRGB(0.2,0.2,colorMapB);

       	// Eliminate zero dots
		if(y1 + x1 + z1 == 0){ 
	    	continue;
		}
        
        positions[ i ]     = y1 * .1;
		positions[ i + 1 ] = x1 * .1;
		positions[ i + 2 ] = z1 * .1;
		
		colors[ i ]     = newColor.r;
		colors[ i + 1 ] = newColor.g;
		colors[ i + 2 ] = newColor.b;
		
		sizes[ vertexCounter] =  map(finalPoints[vertexCounter].x, 0, 5000, 0, 100);

		}
		  
		  
		worker.postMessage(positions); // Send data to our worker.

		//console.log(positions);
		createMesh();

}

function createSphere(){

		var pinkMat = new THREE.MeshPhongMaterial({
		  color      :  new THREE.Color("rgb(226,35,213)"),
		  emissive   :  new THREE.Color("rgb(255,128,64)"),
		  specular   :  new THREE.Color("rgb(255,155,255)"),
		  shininess  :  10,
		  shading    :  THREE.FlatShading,
		  transparent: 1,
		  opacity    : 1
		});


		var icoMaterial =  new THREE.MeshPhongMaterial( { color:new THREE.Color("rgb(255,255,255)"), shading:  THREE.FlatShading, side: THREE.DoubleSide} );

		Ico = new THREE.Mesh(new THREE.IcosahedronGeometry(8,7), pinkMat);
		Ico.dynamic = true;
		Ico.doubleSided = true;

		scene.add(Ico);

}

function updateSphere(deleteFaces){

		var counter = 0;
		for (var i = 0; i <= deleteFaces.length ; i++) {
			if(deleteFaces[i] == 1){		
				counter++;
				Ico.geometry.vertices[Ico.geometry.faces[i].a] = 0;
				Ico.geometry.vertices[Ico.geometry.faces[i].b] = 0;
				Ico.geometry.vertices[Ico.geometry.faces[i].c] = 0;
     			Ico.geometry.verticesNeedUpdate = true;

			}
		}
		console.log(counter);

}

function createMesh(){


	// Create Mesh
	vertexCounterSize = 0;
	vertexCounter = 0;
	skipCounter = 0;
	deleteCounter = 0;
	
     // for(var i = 0; i < 1000; i+=3){  
	for(var i = 0; i < positions.length; i+=3){  


		var newPoint = new THREE.Vector3( positions[ i ],	positions[ i + 1 ] , positions[ i + 2 ]);  
		 

		if(deleteArray[deleteCounter] == 1){
		   deleteCounter ++;
		   skipCounter ++;
		   vertexCounterSize++;
		   continue;
		}

		if(newPoint.x + newPoint.y + newPoint.z == 0){
		   deleteCounter ++;
		   skipCounter ++;
		   vertexCounterSize++;
		   continue;
		} 

		if(vertexCounter % 3 == 0 || vertexCounter == 0){
			if(vertexCounter-1 != -1){
				 particleGeo.faces.push( new THREE.Face3(vertexCounter, vertexCounter+1, vertexCounter-1));
			}else{
				particleGeo.faces.push( new THREE.Face3(vertexCounter, vertexCounter+1, vertexCounter+2));
			}
			   
		}

		deleteCounter ++;
		vertexCounter ++;
		vertexCounterSize++;
		        
		particleGeo.vertices.push(
		   newPoint                
		);


		var newColor = new THREE.Color();
		newColor.setRGB(	colors[ i ], 	colors[ i + 1 ], 	colors[ i + 2 ] );
		customAttributes.customColor.value[ vertexCounter-1] = newColor;
		customAttributes.customSize.value[ vertexCounter-1] =  sizes[vertexCounterSize-1];;


	}

       customAttributes.customColor.needsUpdate = true;
	   customAttributes.customSize.needsUpdate = true;
      
       console.log("skipped: " + skipCounter);

       addToScene();

}

function addToScene(){

		this.shaderMaterial = new THREE.ShaderMaterial( 
		{
			uniforms: 		customUniforms,
			attributes:		customAttributes,
			vertexShader:   document.getElementById( 'vertexshader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
			transparent: true, alphaTest: 0.5,
		});
			
			
		this.particleSystem = new THREE.ParticleSystem( particleGeo, this.shaderMaterial );
		this.particleSystem.position.set(0, 0, 0);
		this.particleSystem.dynamic = true;
		this.particleSystem.frustrumCulled = true;
		this.particleSystem.sortParticles = false;
		this.particleSystem.name = "particleSystem";
		scene.add( this.particleSystem );	

}

function onMouseMove(event){
  
	mouseCoord = new THREE.Vector3( (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5 );
 	
 	calcPointer();

}

function onKeyDown(event) {


			// Space Bar
			if(event.charCode == 32){

				//selectedMesh = new THREE.Geometry();

				for ( var i = 0; i < particleGeo.vertices.length; i ++ ) {
              
		            var vertex = particleGeo.vertices[i];
		             
		              //Get the current camera position  
		            new_pos.copy(camera.position);
		             
		             //Get the smallest distance to the cube and if the distance is smaller than
		             // the distance from camera to cube divided by ten (imaginary contact with sphere),
		             // change the color
		            if(raycaster.ray.distanceToPoint(vertex) <= new_pos.sub(vertex).length()/20 ){
		                  
		                  
		                var newColor = new THREE.Color( 0xffffff );
		                customAttributes.customColor.value[ i ] = newColor;
		                customAttributes.customSize.value[ i ] = 1;
		                  
		                  

   		                selectedMesh.vertices.push(vertex);
		                  

			            var material = new THREE.LineBasicMaterial({color: 0xffffff, opacity: .5 });

			            material.transparent = true;

						var geometry = new THREE.Geometry();
						geometry.vertices.push(
							new THREE.Vector3( 0, 0, 0 ),
							vertex
						);

						var line = new THREE.Line( geometry, material );
						scene.add( line );

		                  
						customAttributes.customColor.needsUpdate = true;
						customAttributes.customSize.needsUpdate = true;

	              	}
	              
	            }
	        } 


	         // Enter
	        if (event.charCode == 0){



	          // Convert Meshes intp ArrayBuffer for Webworker

	        	var selecteMeshBuffer = new Float32Array( selectedMesh.vertices.length * 3);
	          	var icoVertices = new Float32Array(Ico.geometry.vertices.length);
	          	var icoFaces = new Float32Array(Ico.geometry.faces.length * 3);


	        	var vertexCounter = 0;
		        for (var i = 0; i <= selecteMeshBuffer.length - 3; i+=3) {
		        	selecteMeshBuffer[i] =   selectedMesh.vertices[vertexCounter].x;
		          	selecteMeshBuffer[i+1] = selectedMesh.vertices[vertexCounter].y;
		          	selecteMeshBuffer[i+2] = selectedMesh.vertices[vertexCounter].z;
		          	vertexCounter++;
		        };

	          	var vertexCounter = 0;
		        for (var i = 0; i <= icoVertices.length - 3; i+=3) {
		          	icoVertices[i] =   Ico.geometry.vertices[vertexCounter].x;
		          	icoVertices[i+1] = Ico.geometry.vertices[vertexCounter].y;
		          	icoVertices[i+2] = Ico.geometry.vertices[vertexCounter].z;
		          	vertexCounter++;          	

		        };

		        var vertexCounter = 0;
		        for (var i = 0; i <= icoFaces.length - 3; i+=3) {
		          	icoFaces[i] =   Ico.geometry.faces[vertexCounter].centroid.x;
		          	icoFaces[i+1] = Ico.geometry.faces[vertexCounter].centroid.y;
		          	icoFaces[i+2] = Ico.geometry.faces[vertexCounter].centroid.z;
		          	vertexCounter++;
		        };



        		var buffers = [ selecteMeshBuffer, icoVertices, icoFaces];

         		cutoutWorker.postMessage(buffers);


	        }
    
};

function calcPointer(){

	// Create Camera Vector
  cameraVector.applyQuaternion( camera.quaternion );
   
	mouseX = mouseCoord.x;

	//New Projector Class picking ray
   raycaster = projector.pickingRay(mouseCoord, camera);

   var pos = raycaster.ray.intersectPlane(planeZ);


     // Position object near camera - move it along vector between camera and calculated
     // pos
		
		 if(pos != null){
			 new_pos2.copy(pos);  
			}


     new_pos2.sub(camera.position);


     new_pos2.normalize();
     new_pos2.multiplyScalar(20);

     new_pos2.add(camera.position);

     object = scene.getObjectByName( "pointer" );


     object.position.set(new_pos2.x,new_pos2.y,new_pos2.z);
     object.updateMatrix();
}

function checkCamera(){
  if(camera.quaternion.x == cameraOld){
    //console.log("change");
     scene.getObjectByName( "pointer" ).visible = true;
 //  calcPointer();
  } else {
     scene.getObjectByName( "pointer" ).visible = false;
     
  }
  
  cameraOld = camera.quaternion.x;
}

function animate(){
  requestAnimationFrame( animate );
	render();		
	update();

}

function update(){

	if ( keyboard.pressed("z") ) 
	{ 
		// do something
	}

	controls.update();
	stats.update();
    checkCamera();
	//var t = clock.getElapsedTime();
	//customUniforms.time.value = 0.1;
}

function render() 
{
	renderer.render( scene, camera );
}
function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );


}
</script>

</body>
</html>