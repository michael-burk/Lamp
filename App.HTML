<!doctype html>
<html lang="en">
<head>
	<title>ParticleSystem - Dynamic (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body style="overflow:hidden">


<script src="js/Three.js"></script>

<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/jquery-2.1.1.min.js"></script>
<script src="js/cleanMesh.js"></script>
<!--Copyright (C) 2012 Philipp Sackl, envis precisely GmbH-->
<script type="text/javascript" charset="utf-8" src="js/THREE2STL.js"></script>





<!-- Custom shaders for particle effects -->
<script type="x-shader/x-vertex" id="vertexshader">
uniform float time;
attribute float customFrequency;
attribute float customSize;
attribute vec3 customColor;
varying vec3 vColor;
void main() 
{
	vColor = customColor; // set color associated to vertex; use later in fragment shader
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = sin(time) * customSize * 8.0 * ( 10.0 / length( mvPosition.xyz ) );
	gl_Position = projectionMatrix * mvPosition;
}
</script>



<script type="x-shader/x-fragment" id="fragmentshader">
uniform sampler2D texture;
varying vec3 vColor; // colors associated to vertices; assigned by vertex shader
void main() 
{
	// calculates a color for the particle
	gl_FragColor = vec4( vColor, 1.0 );
	// sets particle texture to desired color
	gl_FragColor = gl_FragColor;
}
</script>
<!-- end of custom shaders -->




<!-- jQuery code to display an information button and box when clicked. -->
<script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<script src="js/info.js"></script>



<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>


<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
*/

// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
var cameraOld;

// global variables
var cube;
var zeroCounter = 0;
var particleGeo = new THREE.Geometry();
var vertexCounter = 0;
var vertexCounter1 = 0;
var vertexCounterSize = 0;
var deleteCounter = 0;
var mouseCoord = new THREE.Vector3(0,0,0);
var mouseOpacity;

var positions;
var colors;
var sizes;
var deleteArray;

 var skipCounter;

init();
animate();

var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
direction = new THREE.Vector3( 1, 0, 0 );
myRaycaster = new THREE.Raycaster(camera.position, direction);


var cameraVector = new THREE.Vector3( 0, 0, -1 );
var new_pos = new THREE.Vector3( 0, 0, 0 );
var new_pos2 = new THREE.Vector3( 0, 0, 0 );
var raycaster;
var planeZ = new THREE.Plane(cameraVector, 0);


// FUNCTIONS
 	
function map(x,a,b,c,d){
		return (x-a)/(b-a) * (d-c) + c;
}
	
	
Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};


   var worker = new Worker('js/cleanMesh.js');

	worker.addEventListener('message', function(e) {

		deleteArray = e.data;



		scene.remove(particleSystem);
		particleGeo = new THREE.Geometry();
		createMesh();
		stlFromGeometry( particleGeo, {download:true});
		console.log('Worker said: ', e.data);
		

	}, false);


 
 
	
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	
	projector = new THREE.Projector();
	
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.z = 100;
	camera.lookAt(scene.position);	
	
	// RENDERER
//	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	//else
	//renderer = new THREE.CanvasRenderer(); 
	renderer.setSize( window.innerWidth, window.innerHeight );
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	$( document ).ready(function(){
    $(window).keypress(onKeyDown);
    $(window).mousemove(onMouseMove);
    $(window).mousedown(onMouseMove);    
  });
	window.addEventListener( 'resize', onWindowResize, false );

	
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	
	// LIGHT
  // var light = new THREE.PointLight(0xffffff);
  // light.position.set(0,250,0);
  // scene.add(light);
	
	// SKYBOX/FOG
	var newColor = new THREE.Color( );
  newColor.setRGB(0.9,0.9,0.9);
  
	var skyBoxGeometry = new THREE.CubeGeometry( 15000, 15000, 15000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: newColor, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
  skyBox.flipSided = true; // render faces from inside of the cube, instead of from outside (default).
	scene.add(skyBox);
	
	// Mouse
	
	var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: 0.9 } );
 
	var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
  var pointer = new THREE.Mesh( mouseGeo, pointerMaterial );

  pointer.name = "pointer";
  pointer.position.x = 10;
  pointer.position.y = 10;
  pointer.position.z = 10;
  pointer.updateMatrix();
  pointer.matrixAutoUpdate = false;
  scene.add( pointer );
  
	////////////
	// CUSTOM //
	////////////
	
	var shaderMaterial;
	var particleSystem;
	
	var cubeGeometry = new THREE.CubeGeometry( 50, 50, 50, 20, 20, 20 );
	var discTexture = THREE.ImageUtils.loadTexture( 'disc.png' );
	
	// values that are constant for all particles during a draw call
	this.customUniforms = 
	{
		time:	 { type: "f", value: 1.0 },
		texture: { type: "t", value: discTexture },
	};
	
	// properties that may vary from particle to particle. only accessible in vertex shaders!
	//	(can pass color info to fragment shader via vColor.)
	this.customAttributes = 
	{
		customColor:	 { type: "c", value: [] },
		customFrequency: { type: 'f', value: [] },
		customSize: { type: 'f', value: [] }
	};
	
	

   
   $.getJSON( "LOGFILE.json", function( data ) {
       pointData = data;
       check();
       
   });   


          
  



}

function check() {
     
        particlesCount = Math.floor(Object.size(pointData.points) / 3);

				var color = new THREE.Color();
				
				positions = new Float32Array( particlesCount * 3 );
				colors = new Float32Array( particlesCount * 3);
				sizes = new Float32Array( particlesCount );
				deleteArray = new Int32Array( particlesCount );
	
     for ( var i = 0; i < particlesCount * 3; i += 3 ) {
       
      	if(pointData.points[i] == undefined && i <=  particlesCount * 3){
					console.log("something is wrong in the data at: " + i);
					continue;
       }

		// Point on XZ Plane
		var x = pointData.points[i].x * Math.cos(pointData.points[i].y*(Math.PI/180));
		var y = 0;
		var z = pointData.points[i].x * Math.sin(pointData.points[i].y*(Math.PI/180));

		vertexCounter ++;

		// Eliminate zero dots
		if(y + x + z == 0){ 
	    	continue;
		}

		var angle = (map(pointData.points[i].z, 212, 812, 0, 180))*(Math.PI/180);
		
		//Translate Point
		 x -= 50 * Math.cos(angle);
		 y -= 50 * Math.sin(angle);
		 z -= 0;
		
		// Rotate Point around Z Axis
		x1 = x * Math.cos(angle) - y * Math.sin(angle);
		y1 = x * Math.sin(angle) + y * Math.cos(angle);
		z1 = z;
		

		var colorMapR = map(pointData.points[i].x, 0, 8000, .5, 0);
		var colorMapG = map(pointData.points[i].x, 0, 3000, 0, .5);
		var colorMapB = map(pointData.points[i].x, 0, 5000, .5, .2);


        var newColor = new THREE.Color( );
        newColor.setRGB(0.2,0.2,colorMapB);

       	// Eliminate zero dots
		if(y1 + x1 + z1 == 0){ 
	    	continue;
		}
        
        positions[ i ]     = y1 * .1;
		positions[ i + 1 ] = x1 * .1;
		positions[ i + 2 ] = z1 * .1;
		
		colors[ i ]     = newColor.r;
		colors[ i + 1 ] = newColor.g;
		colors[ i + 2 ] = newColor.b;
		
		sizes[ vertexCounter -1] =  map(pointData.points[i].x, 0, 5000, 0, 100);

		}
		  
		  
		worker.postMessage(positions); // Send data to our worker.
		createMesh();
		  
}

function createMesh(){

		// var count = 0;
		// for (var i = deleteArray.length - 1; i >= 0; i--) {
		// 	if(deleteArray[i] == 1) count++ 
		// };
		// console.log(count);
	

	// Create Mesh
	  vertexCounterSize = 0;
	  vertexCounter = 0;
	  skipCounter = 0;
	  deleteCounter = 0;
	
     // for(var i = 0; i < 1000; i+=3){  
      for(var i = 0; i < positions.length; i+=3){  
        

        var newPoint = new THREE.Vector3( positions[ i ],	positions[ i + 1 ] , positions[ i + 2 ]);  
         
    	
        
        
        if(deleteArray[deleteCounter] == 1){
           deleteCounter ++;
           skipCounter ++;
           vertexCounterSize++;
           continue;
        }

        if(newPoint.x + newPoint.y + newPoint.z == 0){
           deleteCounter ++;
           skipCounter ++;
           vertexCounterSize++;
           continue;
        } 
        
        if(vertexCounter % 3 == 0 || vertexCounter == 0){
        	if(vertexCounter-1 != -1){
        		 particleGeo.faces.push( new THREE.Face3(vertexCounter, vertexCounter+1, vertexCounter-1));
        	}else{
        		particleGeo.faces.push( new THREE.Face3(vertexCounter, vertexCounter+1, vertexCounter+2));
        	}
        	   
        }

        deleteCounter ++;
        vertexCounter ++;
        vertexCounterSize++;
                
        particleGeo.vertices.push(
           newPoint                
        );


     
        
        var newColor = new THREE.Color();
        newColor.setRGB(	colors[ i ], 	colors[ i + 1 ], 	colors[ i + 2 ] );
        customAttributes.customColor.value[ vertexCounter-1] = newColor;
        customAttributes.customSize.value[ vertexCounter-1] =  sizes[vertexCounterSize-1];;
       

      }

       customAttributes.customColor.needsUpdate = true;
	   customAttributes.customSize.needsUpdate = true;
      
       console.log("skipped: " + skipCounter);

		this.shaderMaterial = new THREE.ShaderMaterial( 
		{
			uniforms: 		customUniforms,
			attributes:		customAttributes,
			vertexShader:   document.getElementById( 'vertexshader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
			transparent: true, alphaTest: 0.5,
		});
			
			
			
			
		this.particleSystem = new THREE.ParticleSystem( particleGeo, this.shaderMaterial );
		this.particleSystem.position.set(0, 0, 0);
		this.particleSystem.dynamic = true;
		this.particleSystem.frustrumCulled = true;
		this.particleSystem.sortParticles = false;
		this.particleSystem.name = "particleSystem";
		scene.add( this.particleSystem );	

}

function onMouseMove(event){
  
  mouseCoord = new THREE.Vector3(
      (event.clientX / window.innerWidth) * 2 - 1,
      -(event.clientY / window.innerHeight) * 2 + 1,
      0.5 );
      
  calcPointer();

};

function onKeyDown(event) {

             for ( var i = 0; i < vertexCounter; i ++ ) {
              
             var vertex = particleGeo.vertices[i];
             
              //Get the current camera position  
             new_pos.copy(camera.position);
             
             //Get the smallest distance to the cube and if the distance is smaller than
             // the distance from camera to cube divided by ten (imaginary contact with sphere),
             // change the color
             if(raycaster.ray.distanceToPoint(vertex) <= new_pos.sub(vertex).length()/20 ){
                  
                 // console.log(i);
                  
                  var newColor = new THREE.Color( 0xffffff );
                  customAttributes.customColor.value[ i ] = newColor;
                  customAttributes.customSize.value[ i ] = 20;
                  
                  
                 // console.log(i);
                  
				customAttributes.customColor.needsUpdate = true;
				customAttributes.customSize.needsUpdate = true;

              }
              
             }
     
    
};

function calcPointer(){

	// Create Camera Vector
  cameraVector.applyQuaternion( camera.quaternion );
   
	mouseX = mouseCoord.x;
	//console.log(event.clientX)
	// Mouse Position on Screen (Worldpos?)
   // var mv = new THREE.Vector3(
   //     (event.clientX / window.innerWidth) * 2 - 1,
   //     -(event.clientY / window.innerHeight) * 2 + 1,
   //     0.5 );
     
	//New Projector Class picking ray
   raycaster = projector.pickingRay(mouseCoord, camera);

   var pos = raycaster.ray.intersectPlane(planeZ);


     // Position object near camera - move it along vector between camera and calculated
     // pos
		
		 if(pos != null){
			 new_pos2.copy(pos);  
			}


     new_pos2.sub(camera.position);


     new_pos2.normalize();
     new_pos2.multiplyScalar(20);

     new_pos2.add(camera.position);

     object = scene.getObjectByName( "pointer" );


     object.position.set(new_pos2.x,new_pos2.y,new_pos2.z);
     object.updateMatrix();
}

function checkCamera(){
  if(camera.quaternion.x == cameraOld){
    //console.log("change");
     scene.getObjectByName( "pointer" ).visible = true;
 //  calcPointer();
  } else {
     scene.getObjectByName( "pointer" ).visible = false;
     
  }
  
  cameraOld = camera.quaternion.x;
}

function animate() 
{
  requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	if ( keyboard.pressed("z") ) 
	{ 
		// do something
	}

	controls.update();
	stats.update();
    checkCamera();
	//var t = clock.getElapsedTime();
	//customUniforms.time.value = 0.1;
}

function render() 
{
	renderer.render( scene, camera );
}
function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );


}
</script>

</body>
</html>