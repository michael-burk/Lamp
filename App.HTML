<!doctype html>
<html lang="en">
<head>
	<title>Lamp</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body style="overflow:hidden">


<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/jquery-2.1.1.min.js"></script>
<script src="js/cleanMesh.js"></script>
<script src="js/cutout.js"></script>
<script src="js/FileSaver.min.js"></script>

<!--Copyright (C) 2012 Philipp Sackl, envis precisely GmbH-->
<script type="text/javascript" charset="utf-8" src="js/THREE2STL.js"></script>

<script type="text/javascript" src="js/BinaryLoader.js"></script>
<script type="text/javascript" src="js/STLLoader.js"></script>

<script type="text/javascript" src="js/BoxGeometry.js"></script>
<script type="text/javascript" src="js/TorusGeometry.js"></script>
<script type="text/javascript" src="js/DodecahedronGeometry.js"></script>

<span title="drag&drop data from scanner here"><div id="drop_zone" >Drop files here</div></span>

<span title="optimize scan data">
	<div id="optimize" >
		Optimize
	</div>
</span>

<span title="generate 3D printable geometry">
	<div id="create" >
		Create Lamp
	</div>
</span>

<span title="switch example scan">
	<div id="switch" >
		Switch Room
	</div>
</span>





<!-- Custom shaders for particle effects -->
<script type="x-shader/x-vertex" id="vertexshader">
uniform float time;
attribute float customFrequency;
attribute float customSize;
attribute vec3 customColor;
varying vec3 vColor;
void main() 
{
	vColor = customColor; // set color associated to vertex; use later in fragment shader
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = sin(time) * customSize * 8.0 * ( 10.0 / length( mvPosition.xyz ) );
	gl_Position = projectionMatrix * mvPosition;
}
</script>



<script type="x-shader/x-fragment" id="fragmentshader">
uniform sampler2D texture;
varying vec3 vColor; // colors associated to vertices; assigned by vertex shader
void main() 
{
	// calculates a color for the particle
	gl_FragColor = vec4( vColor, 1.0 );
	// sets particle texture to desired color
	gl_FragColor = gl_FragColor;
}
</script>
<!-- end of custom shaders -->


<!-- jQuery code to display an information button and box when clicked. -->
<!-- <script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<script src="js/info.js"></script> -->



<div id="ThreeJS" style="position: absolute; left:0px; top:0px; z-index: -1;"></div>


<script>

// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
var cameraOld;

// global variables
var cube;
var zeroCounter = 0;
var particleGeo = new THREE.Geometry();
var vertexCounter = 0;
var vertexCounter1 = 0;
var vertexCounterSize = 0;
var deleteCounter = 0;
var mouseCoord = new THREE.Vector3(0,0,0);
var mouseOpacity = 0;
var mouseHold = false;
var mouseCounter = 0;

var positions = new Float32Array( 1000);
var colors;
var sizes;
var cutMeshData;
var deleteArray;

var skipCounter;

var finalPoints;



var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
direction = new THREE.Vector3( 1, 0, 0 );

var cameraVector = new THREE.Vector3( 0, 0, -1 );
var new_pos = new THREE.Vector3( 0, 0, 0 );
var new_pos2 = new THREE.Vector3( 0, 0, 0 );
var raycaster;
var planeZ = new THREE.Plane(cameraVector, 0);

var logText;

//var Ico;
var selectedMesh = new THREE.Geometry();2
var toDelete = [];
var newLampGeo = new THREE.Geometry();
var newLampMesh;

var icoVertices;

var stlName = "room2_opti.stl";

var stlNames = ["room2_opti.stl","room1_opti.stl"];
var stlNameCounter = 0;

//var hole = [17,23,24,25,28,29,33,34,35,36,37,41];

// Settings
var extrude = 1.6;
var thickness = .3;
var recursions = 4;


init();
animate();

// FUNCTIONS
 	
function map(x,a,b,c,d){
		return (x-a)/(b-a) * (d-c) + c;
}
	
	
Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};


// Declare webworker
var worker;
var cutoutWorker;

function startWebworker(){
	 worker = new Worker('js/cleanMesh.js');

	worker.addEventListener('message', function(e) {

		cutMeshData = e.data;
		deleteArray = cutMeshData;
		//console.log(e.data);
		console.log("mesh cleaned");
		scene.remove(particleSystem);
		particleGeo = new THREE.Geometry();
		createMesh();

		exportGeometry();

		//stlFromGeometry( particleGeo, {download:false});
		//console.log('Worker said: ', e.data);
		

	}, false);

	worker.postMessage(positions); // Send data to our worker.

}



function startCutOutWebworker(){
	 	cutoutWorker = new Worker('js/cutout.js');

	cutoutWorker.addEventListener('message', function(e) {

	updateSphere(e.data);
		//console.log('Worker said: ', e.data);
		//console.log(e.data.length);
		

	}, false);

	postToCutOutWorker();
}


 


	
function init(){

	var reader = new FileReader();

	
  function handleDragOver(evt) {

    evt.stopPropagation();
    evt.preventDefault();
    evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.

  }

	function handleFileSelect(evt) {

	if(worker != undefined){
		worker.terminate();
	}

	if(cutoutWorker != undefined){
		cutoutWorker.terminate();
	}
  	

  	//startWebworker();

    evt.stopPropagation();
    evt.preventDefault();

    var files = evt.dataTransfer.files; // FileList object.
    
    //if(files[0].type == "")

    var name = files[0].name;
    var ending = name.substr(name.length-3,3);

    if(ending == "stl"){

    	stlName = name;

    	loadSTL();

    }else if(ending == "txt"){
		// files is a FileList of File objects. List some properties.
	    var output = [];

	    reader.onload = function(e) {
	  		logText = reader.result;
	  		//console.log(logText);
	  		loadTXT();
		}

	    reader.readAsText(files[0]);

    } else {
    	alert("correct file ending?")
    }
   
 

    
    
  }



  // Setup the dnd listeners.
  var dropZone = document.getElementById('drop_zone');
  dropZone.addEventListener('dragover', handleDragOver, false);
  dropZone.addEventListener('drop', handleFileSelect, false);

	// SCENE
	scene = new THREE.Scene();
	
	projector = new THREE.Projector();
	
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.z = 100;
	camera.lookAt(scene.position);	
	
	// RENDERER

	renderer = new THREE.WebGLRenderer( {antialias:true} );

	renderer.setSize( window.innerWidth, window.innerHeight );
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	$( document ).ready(function(){
    	$(window).keypress(onKeyDown);
    	$(window).mousemove(onMouseMove);
    	$(window).mousedown(onMouseDown);
    	
    	$("#optimize").click(function() {
    		alert("The data is getting cleaned. This may take several minutes - up to hours. After the process is finished, a clean .stl file will be available for downloading.");
  			startWebworker();
		});
		$("#create").click(function() {
  			startCutOutWebworker();
		});
		$("#switch").click(function() {
  			switchModel();
		});
  	});

	window.addEventListener( 'resize', onWindowResize, false );

	
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	// STATS
	// stats = new Stats();
	// stats.domElement.style.position = 'absolute';
	// stats.domElement.style.top = '0px';
	// stats.domElement.style.zIndex = 100;
	// container.appendChild( stats.domElement );
	
	// LIGHT
   var light = new THREE.PointLight(0xffffff);
   light.position.set(0,2000,0);
   scene.add(light);

   var light = new THREE.PointLight(0xffffff);
   light.position.set(1000,-1000,0);
   scene.add(light);


	
	// SKYBOX/FOG
	var newColor = new THREE.Color( );
       	//newColor.setRGB(0.9,0.9,0.9);
        newColor.setRGB(0.3,0.3,0.3);
  
	var skyBoxGeometry = new THREE.CubeGeometry( 15000, 15000, 15000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: newColor, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
    skyBox.flipSided = true; // render faces from inside of the cube, instead of from outside (default).
	scene.add(skyBox);
	

	// Mouse
	
	var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: 0.9 } );
	 
	var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
	var pointer = new THREE.Mesh( mouseGeo, pointerMaterial );

	pointer.name = "pointer";
	pointer.position.x = 10;
	pointer.position.y = 10;
	pointer.position.z = 10;
	pointer.updateMatrix();
	pointer.matrixAutoUpdate = false;
	scene.add( pointer );


  
	///////////////////
	// CUSTOM  SHADER//
	///////////////////

	var shaderMaterial;
	var particleSystem;

	//var cubeGeometry = new THREE.CubeGeometry( 50, 50, 50, 20, 20, 20 );
	//var discTexture = THREE.ImageUtils.loadTexture( 'disc.png' );

	// values that are constant for all particles during a draw call
	this.customUniforms = 
	{
		time:	 { type: "f", value: 1.0 }
		
	};

	// properties that may vary from particle to particle. only accessible in vertex shaders!
	//	(can pass color info to fragment shader via vColor.)
	
	this.customAttributes = 
	{
		customColor:	 { type: "c", value: [] },
		customFrequency: { type: 'f', value: [] },
		customSize: { type: 'f', value: [] }
	};
		
 	createSphere(); 
 	  
  	loadSTL();
  
  	// loadTXT();


	// $.ajax({
 //            url : "data/livingRoom2.txt",
 //            dataType: "text",
 //            success : function (data) {
 //            	logText = data;
 //            	//startWebworker();
 //            	loadTXT();
 //            }
 //    });


}


function loadSTL(file){
	var loader = new THREE.STLLoader();

				loader.addEventListener( 'load', function ( event ) {
					
					particleGeo = event.content;

					particlesCount = particleGeo.vertices.length;

					for (var i =  0; i < particlesCount ; i++) {
						

						var pos = new THREE.Vector3(particleGeo.vertices[i].x,particleGeo.vertices[i].y,particleGeo.vertices[i].z);


						var subVector = new THREE.Vector3(0,0,0);
						subVector = pos.sub(new THREE.Vector3(0,0,0));

						var distance = subVector.length();


						var colorMapR = map(distance, 0, 300, .6, 0);
						var colorMapG = map(distance, 0, 300, 0, .5);
						var colorMapB = map(distance, 0, 300, .5, .2);


				        var newColor = new THREE.Color( );
				        newColor.setRGB(1,1,1);


						customAttributes.customColor.value[ i ] = newColor;
        				customAttributes.customSize.value[ i ] =  map(distance, 0, 300, 0, 5);
        				customAttributes.customSize.value[ i ] =  10;

					};

					customAttributes.customColor.needsUpdate = true;
	 				customAttributes.customSize.needsUpdate = true;

					
					addToScene();
				} );


				loader.load( 'data/' + stlName + '' );
				//loader.load(file);
				//loader.load( 'data/room.stl' );

}


function loadTXT(){

	var regFileComplete = /(A|O)/g;

	var counter = 0;

	//vertexCounter = 0;

	// Search for beginning and end in file
	while ((match = regFileComplete.exec(logText)) != null) {
		counter ++;
	}

	if(counter == 2){

		console.log("correct file detected");

		var data = logText.substr(1,logText.length-2);

		//console.log("data: " + data);
		


	//Parser - Get Points

		var regPP = /(P)/g;
		var ppArray = [2];

		var pointsIndex = [];
		var pointCounter = 0; 

		finalPoints = [];


		while ((match = regPP.exec(data)) != null) {

			pointsIndex.push(match.index);
			
			}

			for (var i = 0; i < pointsIndex.length; i++) {
				ppArray[0] = pointsIndex[i];
				ppArray[1] = pointsIndex[i+1];



				if(i % 2 == 0){

					var newPointTXT = new THREE.Vector3(0,0,0);

					var pointValid = false;

					var point = data.substr(ppArray[0]+1,(ppArray[1])-(ppArray[0]+1));

					//Get X Value
						var regXX = /(x)/g;
						var xxArray = [2];
						counter = 0;
						while ((match = regXX.exec(point)) != null) {
							
							if(counter < 3){
								xxArray[counter] =  match.index;
								counter ++;
							}

						}

						var x = point.substr(xxArray[0]+1,xxArray[1]-(xxArray[0]+1));
						
						if( x.length > 0 ){
							//Valid Value
							newPointTXT.x = x;

							pointValid = true;
						} else {
							pointValid = false;
						}


					//Get Y Value
						var regYY = /(y)/g;
						var yyArray = [2];

						counter = 0;

						while ((match = regYY.exec(point)) != null) {
	
							if(counter < 3){
								yyArray[counter] =  match.index;
								counter ++;
							}

						}

						var y = point.substr(yyArray[0]+1,yyArray[1]-(yyArray[0]+1));
						
						if( y.length > 0 ){
							//Valid Value
							newPointTXT.y = y;

							pointValid = true;
						} else {
							pointValid = false;
						}


						


					//Get Z Value

						var regZZ = /(z)/g;
						var zzArray = [2];
						counter = 0;
						while ((match = regZZ.exec(point)) != null) {
							
							if(counter < 3){
								zzArray[counter] =  match.index;
								counter ++;
							}

						}

						var z = point.substr(zzArray[0]+1,zzArray[1]-(zzArray[0]+1));
						
						if( z.length > 0 ){
							//Valid Value
							newPointTXT.z = z;

							pointValid = true;
						} else {
							pointValid = false;
						}


						if(pointValid && (newPointTXT.x + newPointTXT.y) != 0){

							finalPoints.push(newPointTXT);

						}


				}

				
			}
	}


	// Create Point List

	particlesCount = finalPoints.length;

	var color = new THREE.Color();
	
	positions = new Float32Array( particlesCount * 3 );
	colors = new Float32Array( particlesCount * 3);
	sizes = new Float32Array( particlesCount );
	deleteArray = new Int32Array( particlesCount );
	
	vertexCounter = -1;


     for ( var i = 0; i < particlesCount * 3; i += 3 ) {
       
       vertexCounter ++;

		// Point on XZ Plane
		var x = finalPoints[vertexCounter].x * Math.cos(finalPoints[vertexCounter].y*(Math.PI/180));
		var y = 0;
		var z = finalPoints[vertexCounter].x * Math.sin(finalPoints[vertexCounter].y*(Math.PI/180));

		

		// Eliminate zero dots
		if(y + x + z == 0){ 
	    	continue;
		}

		var angle = (map(finalPoints[vertexCounter].z, 175, 805, -5, 175))*(Math.PI/180);
	

		//Translate Point
		 x -=  3 * Math.cos(angle) * (finalPoints[vertexCounter].x * .003); 
		 y -=  3 * Math.sin(angle) * (finalPoints[vertexCounter].x * .003);
		 z -= 0;
		
		// Rotate Point around Z Axis
		x1 = x * Math.cos(angle) - y * Math.sin(angle);
		y1 = x * Math.sin(angle) + y * Math.cos(angle);
		z1 = z;
		
		var distance = finalPoints[vertexCounter].x;
		
		var colorMapR = map(distance, 0, 3000, .6, 0);
		var colorMapG = map(distance, 0, 3000, 0, .5);
		var colorMapB = map(distance, 0, 3000, .5, .2);


        var newColor = new THREE.Color( );
        newColor.setRGB(1,1,1);

       	// Eliminate zero dots
		if(y1 + x1 + z1 == 0){ 
	    	continue;
		}
        
    positions[ i ]     = y1 * -.1;
	positions[ i + 1 ] = (x1 * -.1) - 10;
	positions[ i + 2 ] = z1 * .1;
		
	colors[ i ]     = newColor.r;
	colors[ i + 1 ] = newColor.g;
	colors[ i + 2 ] = newColor.b;
		
	sizes[ vertexCounter] =  map(finalPoints[vertexCounter].x, 0, 3000, 0, 10);

	

	}
		  
		

	//	console.log(positions.length)
		createMesh();

}

function createSphere(){

	var pinkMat = new THREE.MeshPhongMaterial({
		  color      :  new THREE.Color("rgb(100,100,100)"),
		  emissive   :  new THREE.Color("rgb(150,150,150)"),
		  specular   :  new THREE.Color("rgb(155,155,155)"),
		  shininess  :  10,
		  shading    :  THREE.FlatShading,
		  side       : 	THREE.DoubleSide,
		  transparent: 	0,
		  opacity    : 	1,
		  wireframe	 : 	false
		});

	// var loader = new THREE.STLLoader();
	// loader.addEventListener( 'load', function ( event ) {
		
	// 	var bulbGeo = event.content;



	// 	// var icoMaterial =  new THREE.MeshPhongMaterial( { color:new THREE.Color("rgb(255,255,255)"), shading:  THREE.FlatShading, side: THREE.DoubleSide} );


	// 	bulbGeo.computeCentroids();
	// 	bulbGeo.computeFaceNormals();
	// 	bulbGeo.computeVertexNormals(); 


	// 	Ico = new THREE.Mesh(bulbGeo, pinkMat);
	// 	Ico.dynamic = true;
	// 	Ico.doubleSided = true;

	// 	scene.add(Ico);


	// 	//addToScene();
	// } );
	// loader.load( 'data/ico3.stl' );





	Ico = new THREE.Mesh(new THREE.IcosahedronGeometry(9,2), pinkMat);
	Ico.dynamic = true;
	Ico.doubleSided = true;


	var lampGeo = new THREE.Geometry();

	for (var i = 0; i <= Ico.geometry.vertices.length - 1; i++) {

			lampGeo.vertices.push(Ico.geometry.vertices[i]);
			
	}

	for (var i = 0; i <= Ico.geometry.faces.length - 1 ; i++) {

			// var leaveOut = false;

			// for (var j = hole.length - 1; j >= 0; j--) {
			// 	if(hole[j] == i){
			// 		leaveOut = true;
			// 	}

			// };

			// // if( i < 40){
			// // 	leaveOut = true;
			// // }
			// if(!leaveOut){
				lampGeo.faces.push(Ico.geometry.faces[i]);
			// }
			
			
	}

		lampGeo.computeCentroids();
		lampGeo.computeFaceNormals();
		lampGeo.computeVertexNormals(); 

	Ico = new THREE.Mesh(lampGeo, pinkMat);

	scene.add(Ico);
	



}


function updateSphere(cutMeshData){


		newLampGeo = new THREE.Geometry();

		//console.log(cutMeshData);

		//Draw debug boxes

		// var geometry = new THREE.BoxGeometry( .1, .1, .1 );
		// var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); 
		// var cube = new THREE.Mesh( geometry, material );

		if(cutMeshData[2] != undefined){
			for(var i = 0; i <= cutMeshData[2].length -3; i +=3){

				var cube = new THREE.Mesh( geometry, material );
				cube.position = new THREE.Vector3(cutMeshData[2][i],cutMeshData[2][i+1],cutMeshData[2][i+2]);
					scene.add( cube );

			}

		}


		for (var i = 0; i <= cutMeshData[0].length - 3 ; i+=3) {

			newLampGeo.vertices.push(new THREE.Vector3(cutMeshData[0][i],cutMeshData[0][i+1],cutMeshData[0][i+2]));
			
		}


		//	var scaleFactor = 7.5;
		var scaleFactor = 10;
		
		var exportGeo = new THREE.Geometry();

		for (var i = 0; i <= cutMeshData[0].length - 3 ; i+=3) {

			exportGeo.vertices.push(new THREE.Vector3(cutMeshData[0][i]*scaleFactor,cutMeshData[0][i+1]*scaleFactor,cutMeshData[0][i+2]*scaleFactor));
			
		}

		for (var i = 0; i <= cutMeshData[1].length - 3 ; i+=3) {
			newLampGeo.faces.push(new THREE.Face3(cutMeshData[1][i],cutMeshData[1][i+1],cutMeshData[1][i+2]));
		}

		for (var i = 0; i <= cutMeshData[1].length - 3 ; i+=3) {
			exportGeo.faces.push(new THREE.Face3(cutMeshData[1][i],cutMeshData[1][i+1],cutMeshData[1][i+2]));
		}


		newLampGeo.computeCentroids();
		newLampGeo.computeFaceNormals();
		newLampGeo.computeVertexNormals(); 

		exportGeo.computeCentroids();
		exportGeo.computeFaceNormals();
		exportGeo.computeVertexNormals(); 


		//Export STL
		var stl = stlFromGeometry( exportGeo, {download:false});

		var blob = new Blob([stl], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "sphere.stl");
		
		var pinkMat = new THREE.MeshPhongMaterial({
		  color      :  new THREE.Color("rgb(100,100,100)"),
		  emissive   :  new THREE.Color("rgb(150,150,150)"),
		  specular   :  new THREE.Color("rgb(155,155,155)"),
		  shininess  :  10,
		  shading    :  THREE.FlatShading,
		  side       : 	THREE.DoubleSide,
		  transparent: 	0,
		  opacity    : 	1,
		  wireframe	 : 	false
		});

		var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );

		newLampMesh = new THREE.Mesh(newLampGeo, pinkMat);


		newLampMesh.name = "newLampMesh";
		scene.add(newLampMesh);

		scene.remove(Ico);


}

function createMesh(){

	particleGeo = new THREE.Geometry();

	// Create Mesh
	vertexCounterSize = 0;
	vertexCounter = 0;
	skipCounter = 0;
	deleteCounter = 0;
	
     // for(var i = 0; i < 1000; i+=3){  
	for(var i = 0; i < positions.length; i+=3){  


		var newPoint = new THREE.Vector3( positions[ i ],	positions[ i + 1 ] , positions[ i + 2 ]);  
		 
		
		if(deleteArray[deleteCounter] == 1){
		   deleteCounter ++;
		   skipCounter ++;
		   vertexCounterSize++;
		   continue;
		   //console.log("skip");
		}else{
			//console.log("not so skip");
		}

		if(newPoint.x + newPoint.y + newPoint.z == 0){
		   deleteCounter ++;
		   skipCounter ++;
		   vertexCounterSize++;
		   continue;
		} 

		if(vertexCounter % 3 == 0 || vertexCounter == 0){
			if(vertexCounter-1 != -1){
				 particleGeo.faces.push( new THREE.Face3(vertexCounter, vertexCounter+1, vertexCounter-1));
			}else{
				particleGeo.faces.push( new THREE.Face3(vertexCounter, vertexCounter+1, vertexCounter+2));
			}
			   
		}

		deleteCounter ++;
		vertexCounter ++;
		vertexCounterSize++;
		        
		particleGeo.vertices.push(
		   newPoint                
		);


		var newColor = new THREE.Color();
		newColor.setRGB(	colors[ i ], 	colors[ i + 1 ], 	colors[ i + 2 ] );
		customAttributes.customColor.value[ vertexCounter-1] = newColor;
		customAttributes.customSize.value[ vertexCounter-1] =  sizes[vertexCounterSize-1];;


	}

       customAttributes.customColor.needsUpdate = true;
	   customAttributes.customSize.needsUpdate = true;
      
	//   console.log("skipped: " + skipCounter);

       addToScene();

}

function addToScene(){


		if(scene.getObjectByName("particleSystem") != undefined){
			scene.remove(particleSystem);
		}

		this.shaderMaterial = new THREE.ShaderMaterial( 
		{
			uniforms: 		customUniforms,
			attributes:		customAttributes,
			vertexShader:   document.getElementById( 'vertexshader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
			transparent: true,
			alphaTest: 0.5
		});
			

			
		this.particleSystem = new THREE.ParticleSystem( particleGeo, this.shaderMaterial );
		this.particleSystem.position.set(0, 0, 0);
		this.particleSystem.dynamic = true;
		this.particleSystem.frustrumCulled = true;
		this.particleSystem.sortParticles = false;
		this.particleSystem.name = "particleSystem";
		scene.add( this.particleSystem );	



}

function switchModel(){
	
	stlNameCounter ++;

	if(stlNameCounter >= stlNames.length){
		stlNameCounter = 0;
	}
	stlName = stlNames[stlNameCounter];
	
	loadSTL();
}

function onMouseMove(event){
  
	mouseCoord = new THREE.Vector3( (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5 );
 	
 	calcPointer();

 	

}

function onMouseDown(){
	mouseHold = true;
	mouseOpacity = 0;
	mouseCounter = 0;
	updatePointerColor(mouseOpacity);
}

function onKeyDown(event) {


		// Space Bar
			if(event.charCode == 32){

				//selectedMesh = new THREE.Geometry();

				for ( var i = 0; i < particleGeo.vertices.length; i ++ ) {
              
		            var vertex = particleGeo.vertices[i];
		             
		              //Get the current camera position  
		            new_pos.copy(camera.position);
		             
		             //Get the smallest distance to the cube and if the distance is smaller than
		             // the distance from camera to cube divided by ten (imaginary contact with sphere),
		             // change the color
		            if(raycaster.ray.distanceToPoint(vertex) <= new_pos.sub(vertex).length()/20 ){
		                  
		                  

		                var newColor = new THREE.Color( );
       					
       					newColor.setRGB(.9,.8,.2);

		                
		                customAttributes.customColor.value[ i ] = newColor;
		                customAttributes.customSize.value[ i ] = 25;
		                  
		                  

   		                selectedMesh.vertices.push(vertex);
		                  
		                  


			            var material = new THREE.LineBasicMaterial({color: newColor, opacity: .5 });

			            material.transparent = true;

						var geometry = new THREE.Geometry();
						geometry.vertices.push(
							new THREE.Vector3( 0, 0, 0 ),
							vertex
						);

						var line = new THREE.Line( geometry, material );
					//	scene.add( line );

		                  
						customAttributes.customColor.needsUpdate = true;
						customAttributes.customSize.needsUpdate = true;

	              	}
	              
	            }
	        } 

    
};

function postToCutOutWorker(){
	 // Convert Mesh data into ArrayBuffer for Webworker

	        	var selecteMeshBuffer = new Float32Array( selectedMesh.vertices.length * 3);
	          	var icoVertices = new Float32Array((Ico.geometry.vertices.length - 0) * 3);
	          	var icoFacesCentroids = new Float32Array((Ico.geometry.faces.length -0) * 3);
	          	var icoFaces = new Float32Array((Ico.geometry.faces.length -0) * 3);


	        	var vertexCounter = 0;
		        for (var i = 0; i <= selecteMeshBuffer.length - 3; i+=3) {
		        	selecteMeshBuffer[i] =   selectedMesh.vertices[vertexCounter].x;
		          	selecteMeshBuffer[i+1] = selectedMesh.vertices[vertexCounter].y;
		          	selecteMeshBuffer[i+2] = selectedMesh.vertices[vertexCounter].z;
		          	vertexCounter++;
		        };

	          	var vertexCounter = 0;
		        for (var i = 0; i <= icoVertices.length - 3; i+=3) {
					icoVertices[i] =   Ico.geometry.vertices[vertexCounter].x;
	         	 	icoVertices[i+1] = Ico.geometry.vertices[vertexCounter].y;
	          		icoVertices[i+2] = Ico.geometry.vertices[vertexCounter].z;

		          	vertexCounter++;   	
		        };

		        var vertexCounter = 0;
		        for (var i = 0; i <= icoFaces.length - 3; i+=3) {
		        	// if(vertexCounter == 0){
		        	// 	icoFacesCentroids[i] =   0;
		         //  		icoFacesCentroids[i+1] = 0;
		         //  		icoFacesCentroids[i+2] = 0;
		        	// }else{


		          	icoFacesCentroids[i] =   Ico.geometry.faces[vertexCounter].centroid.x;
		          	icoFacesCentroids[i+1] = Ico.geometry.faces[vertexCounter].centroid.y;
		          	icoFacesCentroids[i+2] = Ico.geometry.faces[vertexCounter].centroid.z;
		          	// }
		          	vertexCounter++;
		        };

				var vertexCounter = 0;
		        for (var i = 0; i <= icoFaces.length - 3; i+=3) {
		        	// if(vertexCounter == 0){
		        	// 	icoFaces[i] =   0;
		         //  		icoFaces[i+1] = 0;
		         //  		icoFaces[i+2] = 0;
		        	// } else {


		          	icoFaces[i] =   Ico.geometry.faces[vertexCounter].a;
		          	icoFaces[i+1] = Ico.geometry.faces[vertexCounter].b;
		          	icoFaces[i+2] = Ico.geometry.faces[vertexCounter].c;
		         	// }
		          	vertexCounter++;
		        };



        		var buffers = [ selecteMeshBuffer, icoVertices, icoFacesCentroids, icoFaces, extrude, thickness, recursions];

        		//console.log(buffers);
        		//console.log(selecteMeshBuffer);
         		cutoutWorker.postMessage(buffers);
}

function calcPointer(){

	// Create Camera Vector
  cameraVector.applyQuaternion( camera.quaternion );
   
	mouseX = mouseCoord.x;

	//New Projector Class picking ray
   raycaster = projector.pickingRay(mouseCoord, camera);

   var pos = raycaster.ray.intersectPlane(planeZ);


     // Position object near camera - move it along vector between camera and calculated
     // pos
		
		 if(pos != null){
			 new_pos2.copy(pos);  
			}


     new_pos2.sub(camera.position);


     new_pos2.normalize();
     new_pos2.multiplyScalar(20);

     new_pos2.add(camera.position);

     object = scene.getObjectByName( "pointer" );


     object.position.set(new_pos2.x,new_pos2.y,new_pos2.z);
     object.updateMatrix();
}

function exportGeometry(){
	var stl = stlFromGeometry( particleGeo, {download:false});

	var blob = new Blob([stl], {type: "text/plain;charset=utf-8"});
	saveAs(blob, "room.stl");
}

function updatePointerColor(opacity){
	//console.log("update color");
	var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: opacity } );

	scene.getObjectByName( "pointer" ).material = pointerMaterial;
	scene.getObjectByName( "pointer" ).material.needsUpdate = true;
}

function checkCamera(){
 if(camera.quaternion.x == cameraOld){
    //console.log("change");
   // mouseHold = true;
  // scene.getObjectByName( "pointer" ).visible = true;
    //calcPointer();
  } else {
     mouseHold = true;
	 mouseOpacity = 0;
	 mouseCounter = 0;
	 updatePointerColor(mouseOpacity);
     
 }
  
 cameraOld = camera.quaternion.x;
}

function animate(){
  requestAnimationFrame( animate );
	render();		
	update();

}

function update(){

//console.log(mouseOpacity);
	
	if(mouseOpacity >= 1){
		mouseHold = false;
	}

	if ( mouseHold) 
	{ 	
		if(mouseCounter <= 1){
			mouseCounter += .01;
		}
		
		if(mouseCounter > .5){
			mouseOpacity += .1;

			updatePointerColor(mouseOpacity);
		}
		
	}

	

	

	controls.update();
	//stats.update();
    //checkCamera();
	//var t = clock.getElapsedTime();
	//customUniforms.time.value = 0.1;
}

function render() 
{
	renderer.render( scene, camera );
}
function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );


}
</script>

</body>
</html>