
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - orbit controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;

			}

			a {
				color: red;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>
		

		<script src="js/three.min.js"></script>

		<script src="js/OrbitControls.js"></script>
    <script src="js/Raycaster.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/stats.min.js"></script>
    <script src="js/jquery-2.1.1.min.js"></script>
		
		<script>
		
		window.requestAnimFrame = (function(){
	      return  window.requestAnimationFrame       || 
	              window.webkitRequestAnimationFrame || 
	              window.mozRequestAnimationFrame    || 
	              window.oRequestAnimationFrame      || 
	              window.msRequestAnimationFrame     || 
	              function(/* function */ callback, /* DOMElement */ element){
	                window.setTimeout(callback, 1000 / 60);
	              };
	    })();
    
    

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, controls, scene, renderer;
      
			init();
			update();

      
      Object.size = function(obj) {
          var size = 0, key;
          for (key in obj) {
              if (obj.hasOwnProperty(key)) size++;
          }
          return size;
      };
     
      
      var pointData = new Object;
      var particlesCount; 
      var positions;
      var particleGeo ;
      	
			function init() {
			  
	      particleGeo = new THREE.BufferGeometry();
	      
        projector = new THREE.Projector();
        
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.z = 10;
        
        
				controls = new THREE.OrbitControls( camera );
				controls.damping = 0.2;

				scene = new THREE.Scene();
        
       var spriteMaterial = new THREE.SpriteMaterial({color: 0xffffff, fog: false});
       
		   var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
               
               
        direction = new THREE.Vector3( 1, 0, 0 );
        myRaycaster = new THREE.Raycaster(camera.position, direction);
				
				
				// world
          
				var geometry = new THREE.BoxGeometry( 2, 2, 2, 2, 2 );
        

                
                $.getJSON( "room_large.json", function( data ) {
                    pointData = data;
                    check();
                });   
                       
                function check() {
                  
                    particlesCount = Math.floor(Object.size(pointData.points) / 3);
            			

            				positions = new Float32Array( particlesCount * 3 );
            				var colors = new Float32Array( particlesCount * 3 );

            				var color = new THREE.Color();

            				var n = 1000, n2 = n / 2; // particles spread in the cube
                    				
                    
                  for ( var i = 0; i < positions.length; i += 3 ) {
                   
                    var x = pointData.points[i].x;
                    var y = pointData.points[i].y - 200;
                    var z = pointData.points[i].z;

          					positions[ i ]     = x;
          					positions[ i + 1 ] = y;
          					positions[ i + 2 ] = z;

          					// colors

          					var vx = ( x / n ) + 0.5;
          					var vy = ( y / n ) + 0.5;
          					var vz = ( z / n ) + 0.5;

          				//	color.setRGB( vx, vy, vz );
          					color.setRGB( 0, 0, 0 );

          					colors[ i ]     = color.r;
          					colors[ i + 1 ] = color.g;
          					colors[ i + 2 ] = color.b;

          				}
          				
          					particleGeo.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
            				particleGeo.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

            				particleGeo.computeBoundingSphere();


            				var material = new THREE.PointCloudMaterial( { size: 3, vertexColors: THREE.VertexColors } );

            				particleSystem = new THREE.PointCloud( particleGeo, material );
            				scene.add( particleSystem );
                }
                  
								
								var material = new THREE.MeshBasicMaterial({
									color: 0x0000ff
								});
								
								var pointerMaterial =  new THREE.MeshBasicMaterial( { color:0xffffff, transparent: true ,opacity: 0.5 } );
				       
								var mouseGeo = new THREE.SphereGeometry( 1, 36, 36);
							  var pointer = new THREE.Mesh( mouseGeo, pointerMaterial );

							  pointer.name = "pointer";
				        pointer.position.x = 10;
				        pointer.position.y = 10;
				        pointer.position.z = 10;
				        pointer.updateMatrix();
				        pointer.matrixAutoUpdate = false;
				        scene.add( pointer );
								
							
								
								
				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0xcccccc, 1 );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

        stats = new Stats();
           stats.domElement.style.position = 'absolute';
           stats.domElement.style.top = '0px';
           stats.domElement.style.zIndex = 100;
           container.appendChild( stats.domElement );


				window.addEventListener( 'resize', onWindowResize, false );
				$(window).keypress(onKeyDown);
				$(window).mousemove(onMouseMove);


        
       
        

			}
      
      var new_pos = new THREE.Vector3(0,0,0);

      
      
      function onKeyDown(event) {

                   for ( var i = 0; i < positions.length-3; i += 3 ) {
                   var vertex = new THREE.Vector3(particleSystem.geometry.attributes.position.array[i],
                                                   particleSystem.geometry.attributes.position.array[i+1],
                                                   particleSystem.geometry.attributes.position.array[i+2]);
                    
                   
                    //Get the current camera position  
                   new_pos .copy(camera.position);
                   
                   //Get the smallest distance to the cube and if the distance is smaller than
                   // the distance from camera to cube divided by ten (imaginary contact with sphere),
                   // change the color
                   if(raycaster.ray.distanceToPoint(vertex) <= new_pos.sub(vertex).length()/10 ){
                                                                                   
               					particleSystem.geometry.attributes.color.array[ i ]     = 0xffffff;
               					particleSystem.geometry.attributes.color.array[ i + 1 ] = 0xffffff;
               					particleSystem.geometry.attributes.color.array[ i + 2 ] = 0xffffff;
               					
												particleSystem.geometry.attributes.color.needsUpdate = true;
												
                    }
                    
                   }
           
          
      };
      
      
      
      var cameraVector = new THREE.Vector3( 0, 0, -1 );
			var new_pos2 = new THREE.Vector3( 0, 0, 0 );
      var raycaster;
      var planeZ = new THREE.Plane(cameraVector, 0);
      
      function onMouseMove(event){
        
				// Create Camera Vector
        cameraVector.applyQuaternion( camera.quaternion );
         
				// Mouse Position on Screen (Worldpos?)
         var mv = new THREE.Vector3(
             (event.clientX / window.innerWidth) * 2 - 1,
             -(event.clientY / window.innerHeight) * 2 + 1,
             0.5 );
           
				//New Projector Class picking ray
         raycaster = projector.pickingRay(mv, camera);

			    var pos = raycaster.ray.intersectPlane(planeZ);


	         // Position object near camera - move it along vector between camera and calculated
	         // pos
					
					 if(pos != null){
						 new_pos2.copy(pos);  
						}


	         new_pos2.sub(camera.position);


	         new_pos2.normalize();
	         new_pos2.multiplyScalar(10);

	         new_pos2.add(camera.position);

	         object = scene.getObjectByName( "pointer" );


	         object.position.set(new_pos2.x,new_pos2.y,new_pos2.z);
	         object.updateMatrix();
        

      };
      
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );


			}

			
			// animation loop
			function update() {
				controls.update();
				stats.update();
				renderer.render( scene, camera );
				requestAnimFrame(update);
			}

		</script>

	</body>
</html>
